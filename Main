Sub CalculerBornes()
    On Error GoTo ErrorHandler
    
    Dim wsSource As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim resultRow As Long
    
    ' Structure pour stocker les données temporaires
    Dim tempData As Variant
    Dim tempCount As Long
    
    ' Variables pour les données de chaque ligne
    Dim tournee As String, libelleDistrict As String, ligne3 As String
    Dim numero As String, motDirecteur As String, voie As String
    Dim commune As String, secable As String, samedi As String
    
    ' 1. Identifier la feuille source
    Set wsSource = ThisWorkbook.Worksheets(1)
    
    ' 2. Supprimer la feuille "Calcul des bornes" si elle existe
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    ' 3. Créer la nouvelle feuille "Calcul des bornes"
    Set wsResult = ThisWorkbook.Worksheets.Add
    wsResult.Name = "Calcul des bornes"
    
    ' 4. Créer les en-têtes
    With wsResult
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Formatage des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(220, 220, 220)
    End With
    
    ' 5. Lire toutes les données valides
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    ' Lire directement la plage de données
    If lastRow > 1 Then
        tempData = wsSource.Range("A2:I" & lastRow).Value
    Else
        MsgBox "Aucune donnée trouvée dans la feuille source.", vbWarning
        Exit Sub
    End If
    
    ' 6. Traiter les données
    resultRow = 2
    Dim processedGroups As String
    processedGroups = "|" ' Commencer avec un délimiteur
    
    For i = 1 To UBound(tempData, 1)
        ' Récupérer les valeurs de la ligne
        commune = GetStringValue(tempData(i, 7))
        motDirecteur = GetStringValue(tempData(i, 5))
        voie = GetStringValue(tempData(i, 6))
        numero = GetStringValue(tempData(i, 4))
        
        ' Vérifier que le numéro est valide
        If numero <> "" And IsNumeric(numero) Then
            Dim currentGroupKey As String
            currentGroupKey = commune & "§" & motDirecteur & "§" & voie
            
            ' Vérifier si ce groupe a déjà été traité
            If InStr(processedGroups, "|" & currentGroupKey & "|") = 0 Then
                processedGroups = processedGroups & currentGroupKey & "|"
                
                ' Traiter ce groupe
                TraiterGroupeSimple tempData, currentGroupKey, wsResult, resultRow
            End If
        End If
    Next i
    
    ' 7. Ajuster la largeur des colonnes
    wsResult.Columns("A:I").AutoFit
    
    MsgBox "Calcul des bornes terminé. " & (resultRow - 2) & " lignes générées.", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur : " & Err.Description & " (Ligne: " & i & ", Numéro d'erreur: " & Err.Number & ")", vbCritical
End Sub

' Fonction pour récupérer une valeur string de manière sécurisée
Private Function GetStringValue(value As Variant) As String
    If IsNull(value) Or IsEmpty(value) Then
        GetStringValue = ""
    Else
        GetStringValue = Trim(CStr(value))
    End If
End Function

' Subroutine pour traiter un groupe d'adresses
Private Sub TraiterGroupeSimple(allData As Variant, groupKey As String, wsResult As Worksheet, ByRef resultRow As Long)
    Dim i As Long
    Dim groupAddresses As String
    Dim groupInfo As String
    
    ' Extraire les clés du groupe
    Dim groupParts As Variant
    groupParts = Split(groupKey, "§")
    Dim targetCommune As String, targetMotDirecteur As String, targetVoie As String
    targetCommune = groupParts(0)
    targetMotDirecteur = groupParts(1)
    targetVoie = groupParts(2)
    
    ' Collecter toutes les adresses de ce groupe
    For i = 1 To UBound(allData, 1)
        Dim commune As String, motDirecteur As String, voie As String, numero As String
        commune = GetStringValue(allData(i, 7))
        motDirecteur = GetStringValue(allData(i, 5))
        voie = GetStringValue(allData(i, 6))
        numero = GetStringValue(allData(i, 4))
        
        If commune = targetCommune And motDirecteur = targetMotDirecteur And voie = targetVoie Then
            If numero <> "" And IsNumeric(numero) Then
                Dim tournee As String, secable As String, samedi As String
                tournee = GetStringValue(allData(i, 1))
                secable = GetStringValue(allData(i, 8))
                samedi = GetStringValue(allData(i, 9))
                
                ' Stocker les informations de l'adresse
                Dim adresseInfo As String
                adresseInfo = numero & ";" & tournee & ";" & secable & ";" & samedi
                
                If groupAddresses = "" Then
                    groupAddresses = adresseInfo
                    ' Stocker les informations communes du groupe
                    groupInfo = GetStringValue(allData(i, 2)) & ";" & GetStringValue(allData(i, 3)) ' libelleDistrict;ligne3
                Else
                    groupAddresses = groupAddresses & "|" & adresseInfo
                End If
            End If
        End If
    Next i
    
    ' Analyser et traiter le groupe
    If groupAddresses <> "" Then
        AnalyserEtEcrireGroupe targetCommune, targetMotDirecteur, targetVoie, groupInfo, groupAddresses, wsResult, resultRow
    End If
End Sub

' Subroutine pour analyser et écrire un groupe
Private Sub AnalyserEtEcrireGroupe(commune As String, motDirecteur As String, voie As String, _
    groupInfo As String, groupAddresses As String, wsResult As Worksheet, ByRef resultRow As Long)
    
    ' Extraire les infos communes
    Dim infoParts As Variant
    infoParts = Split(groupInfo, ";")
    Dim libelleDistrict As String, ligne3 As String
    libelleDistrict = infoParts(0)
    ligne3 = infoParts(1)
    
    ' Séparer les adresses
    Dim adresses As Variant
    adresses = Split(groupAddresses, "|")
    
    ' Vérifier si la voie est complète
    Dim refTournee As String, refSecable As String, refSamedi As String
    Dim premierAdresse As Variant
    premierAdresse = Split(adresses(0), ";")
    refTournee = premierAdresse(1)
    refSecable = premierAdresse(2)
    refSamedi = premierAdresse(3)
    
    Dim estComplete As Boolean
    estComplete = True
    
    Dim i As Long
    For i = 1 To UBound(adresses)
        Dim currentAdresse As Variant
        currentAdresse = Split(adresses(i), ";")
        
        If currentAdresse(1) <> refTournee Or currentAdresse(2) <> refSecable Or currentAdresse(3) <> refSamedi Then
            estComplete = False
            Exit For
        End If
    Next i
    
    If estComplete Then
        ' Voie complète
        EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, "", _
            libelleDistrict, refTournee, refSecable, refSamedi
        resultRow = resultRow + 1
    Else
        ' Voie non complète - calculer les bornes par sous-groupe
        CalculerBornesParSousGroupeSimple commune, motDirecteur, voie, ligne3, libelleDistrict, adresses, wsResult, resultRow
    End If
End Sub

' Subroutine pour calculer les bornes par sous-groupe
Private Sub CalculerBornesParSousGroupeSimple(commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, libelleDistrict As String, adresses As Variant, wsResult As Worksheet, ByRef resultRow As Long)
    
    Dim processedSubGroups As String
    processedSubGroups = "|"
    
    Dim i As Long
    For i = 0 To UBound(adresses)
        Dim currentAdresse As Variant
        currentAdresse = Split(adresses(i), ";")
        
        Dim subGroupKey As String
        subGroupKey = currentAdresse(1) & "§" & currentAdresse(2) & "§" & currentAdresse(3) ' tournee§secable§samedi
        
        If InStr(processedSubGroups, "|" & subGroupKey & "|") = 0 Then
            processedSubGroups = processedSubGroups & subGroupKey & "|"
            
            ' Collecter tous les numéros de ce sous-groupe
            Dim pairsList As String, impairsList As String
            pairsList = ""
            impairsList = ""
            
            Dim j As Long
            For j = 0 To UBound(adresses)
                Dim otherAdresse As Variant
                otherAdresse = Split(adresses(j), ";")
                
                Dim otherSubGroupKey As String
                otherSubGroupKey = otherAdresse(1) & "§" & otherAdresse(2) & "§" & otherAdresse(3)
                
                If otherSubGroupKey = subGroupKey Then
                    Dim numero As Long
                    numero = CLng(otherAdresse(0))
                    
                    If numero Mod 2 = 0 Then
                        If pairsList = "" Then
                            pairsList = CStr(numero)
                        Else
                            pairsList = pairsList & "," & CStr(numero)
                        End If
                    Else
                        If impairsList = "" Then
                            impairsList = CStr(numero)
                        Else
                            impairsList = impairsList & "," & CStr(numero)
                        End If
                    End If
                End If
            Next j
            
            ' Écrire les bornes
            If pairsList <> "" Then
                Dim bornePairs As String
                bornePairs = CalculerBorneDepuisListe(pairsList)
                EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, bornePairs, _
                    libelleDistrict, currentAdresse(1), currentAdresse(2), currentAdresse(3)
                resultRow = resultRow + 1
            End If
            
            If impairsList <> "" Then
                Dim borneImpairs As String
                borneImpairs = CalculerBorneDepuisListe(impairsList)
                EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, borneImpairs, _
                    libelleDistrict, currentAdresse(1), currentAdresse(2), currentAdresse(3)
                resultRow = resultRow + 1
            End If
        End If
    Next i
End Sub

' Fonction pour calculer une borne à partir d'une liste de numéros
Private Function CalculerBorneDepuisListe(listeNumeros As String) As String
    If listeNumeros = "" Then
        CalculerBorneDepuisListe = ""
        Exit Function
    End If
    
    Dim numerosArray As Variant
    numerosArray = Split(listeNumeros, ",")
    
    ' Convertir et trier
    Dim numArray() As Long
    ReDim numArray(0 To UBound(numerosArray))
    
    Dim i As Long, j As Long, temp As Long
    For i = 0 To UBound(numerosArray)
        numArray(i) = CLng(numerosArray(i))
    Next i
    
    ' Tri simple
    For i = 0 To UBound(numArray) - 1
        For j = i + 1 To UBound(numArray)
            If numArray(i) > numArray(j) Then
                temp = numArray(i)
                numArray(i) = numArray(j)
                numArray(j) = temp
            End If
        Next j
    Next i
    
    ' Retourner la borne
    If UBound(numArray) = 0 Then
        CalculerBorneDepuisListe = CStr(numArray(0))
    Else
        CalculerBorneDepuisListe = CStr(numArray(0)) & " → " & CStr(numArray(UBound(numArray)))
    End If
End Function

' Subroutine pour écrire une ligne de résultat
Private Sub EcrireLigneResultat(ws As Worksheet, row As Long, _
    commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, borne As String, libelleDistrict As String, _
    tournee As String, secable As String, samedi As String)
    
    With ws
        .Cells(row, 1).Value = commune
        .Cells(row, 2).Value = motDirecteur
        .Cells(row, 3).Value = voie
        .Cells(row, 4).Value = ligne3
        .Cells(row, 5).Value = borne
        .Cells(row, 6).Value = libelleDistrict
        .Cells(row, 7).Value = tournee
        .Cells(row, 8).Value = secable
        .Cells(row, 9).Value = samedi
    End With
End Sub
