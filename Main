Sub CalculerBornes()
    '=========================================================================
    ' MACRO CALCUL DES BORNES - INDICATEUR TG
    ' Auteur: Développé selon les spécifications fournies
    ' Date: Juin 2025
    ' 
    ' Objectif: Calculer les bornes de numéros pour chaque voie selon les règles:
    ' - Si voie complète (même Tournée, Sécable, Samedi) -> une ligne sans borne
    ' - Sinon -> calcul des bornes séparément pour pairs et impairs
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim currentRow As Long
    
    ' Dictionnaires pour regrouper les données
    Dim voiesData As Object
    Set voiesData = CreateObject("Scripting.Dictionary")
    
    ' Variables pour la ligne en cours
    Dim commune As String, motDirecteur As String, voie As String, ligne3 As String
    Dim numero As Variant, libelleDistrict As String, tournee As String
    Dim secable As String, samedi As String
    Dim cleVoie As String
    
    On Error GoTo ErrorHandler
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    ' Chercher la feuille principale (peut avoir différents noms)
    Set ws = Nothing
    For Each ws In ThisWorkbook.Worksheets
        If ws.Name <> "Calcul des bornes" Then
            ' Vérifier si cette feuille contient les bonnes colonnes
            If ws.Cells(1, 1).Value = "Tournée" And _
               ws.Cells(1, 4).Value = "Numéro" And _
               ws.Cells(1, 6).Value = "Voie" Then
                Exit For
            End If
        End If
    Next ws
    
    If ws Is Nothing Then
        MsgBox "Impossible de trouver la feuille source avec les colonnes requises.", vbCritical
        Exit Sub
    End If
    
    ' 2. SUPPRESSION ET CRÉATION DE LA FEUILLE "Calcul des bornes"
    '=========================================================================
    Application.DisplayAlerts = False
    
    ' Supprimer la feuille si elle existe
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    
    ' Créer la nouvelle feuille
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' Créer les en-têtes selon les spécifications exactes
    With wsCalcul
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Mise en forme des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(180, 198, 231)
        .Range("A1:I1").Borders.LineStyle = xlContinuous
    End With
    
    Application.DisplayAlerts = True
    
    ' 3. LECTURE ET REGROUPEMENT DES DONNÉES
    '=========================================================================
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    ' Parcourir toutes les lignes de données
    For i = 2 To lastRow
        ' Lire les données de la ligne courante
        tournee = Trim(CStr(ws.Cells(i, 1).Value))
        libelleDistrict = Trim(CStr(ws.Cells(i, 2).Value))
        ligne3 = Trim(CStr(ws.Cells(i, 3).Value))
        numero = ws.Cells(i, 4).Value
        motDirecteur = Trim(CStr(ws.Cells(i, 5).Value))
        voie = Trim(CStr(ws.Cells(i, 6).Value))
        commune = Trim(CStr(ws.Cells(i, 7).Value))
        secable = Trim(CStr(ws.Cells(i, 8).Value))
        samedi = Trim(CStr(ws.Cells(i, 9).Value))
        
        ' Ignorer les lignes sans données essentielles
        If commune = "" Or voie = "" Or tournee = "" Then GoTo NextRow
        
        ' Créer la clé unique pour la voie
        cleVoie = commune & "|" & voie & "|" & motDirecteur
        
        ' Initialiser le dictionnaire pour cette voie si nécessaire
        If Not voiesData.Exists(cleVoie) Then
            Set voiesData(cleVoie) = CreateObject("Scripting.Dictionary")
            voiesData(cleVoie)("commune") = commune
            voiesData(cleVoie)("motDirecteur") = motDirecteur
            voiesData(cleVoie)("voie") = voie
            voiesData(cleVoie)("ligne3") = ligne3
            voiesData(cleVoie)("libelleDistrict") = libelleDistrict
            voiesData(cleVoie)("tournees") = CreateObject("Scripting.Dictionary")
            voiesData(cleVoie)("secables") = CreateObject("Scripting.Dictionary")
            voiesData(cleVoie)("samedis") = CreateObject("Scripting.Dictionary")
            voiesData(cleVoie)("numeros") = CreateObject("Scripting.Dictionary")
        End If
        
        ' Ajouter les valeurs aux ensembles
        If tournee <> "" Then voiesData(cleVoie)("tournees")(tournee) = True
        If secable <> "" Then voiesData(cleVoie)("secables")(secable) = True
        If samedi <> "" Then voiesData(cleVoie)("samedis")(samedi) = True
        
        ' Ajouter le numéro s'il est valide
        If IsNumeric(numero) And numero <> "" Then
            Dim numInt As Long
            numInt = CLng(numero)
            If numInt > 0 Then
                voiesData(cleVoie)("numeros")(numInt) = tournee & "|" & secable & "|" & samedi
            End If
        End If
        
NextRow:
    Next i
    
    ' 4. TRAITEMENT ET ÉCRITURE DES RÉSULTATS
    '=========================================================================
    currentRow = 2
    Dim cleVoieArray As Variant
    cleVoieArray = voiesData.Keys
    
    Dim j As Long
    For j = 0 To UBound(cleVoieArray)
        Dim voieInfo As Object
        Set voieInfo = voiesData(cleVoieArray(j))
        
        commune = voieInfo("commune")
        motDirecteur = voieInfo("motDirecteur")
        voie = voieInfo("voie")
        ligne3 = voieInfo("ligne3")
        libelleDistrict = voieInfo("libelleDistrict")
        
        ' Déterminer si la voie est "complète"
        Dim estComplete As Boolean
        estComplete = (voieInfo("tournees").Count = 1) And _
                     (voieInfo("secables").Count <= 1) And _
                     (voieInfo("samedis").Count <= 1)
        
        If estComplete Then
            ' 4A. VOIE COMPLÈTE - Une seule ligne sans borne
            '=================================================================
            Dim tourneeUnique As String, secableUnique As String, samediUnique As String
            
            ' Récupérer les valeurs uniques
            Dim keyArray As Variant
            keyArray = voieInfo("tournees").Keys
            tourneeUnique = keyArray(0)
            
            secableUnique = ""
            If voieInfo("secables").Count > 0 Then
                keyArray = voieInfo("secables").Keys
                secableUnique = keyArray(0)
            End If
            
            samediUnique = ""
            If voieInfo("samedis").Count > 0 Then
                keyArray = voieInfo("samedis").Keys
                samediUnique = keyArray(0)
            End If
            
            ' Écrire la ligne
            With wsCalcul
                .Cells(currentRow, 1).Value = commune
                .Cells(currentRow, 2).Value = motDirecteur
                .Cells(currentRow, 3).Value = voie
                .Cells(currentRow, 4).Value = ligne3
                .Cells(currentRow, 5).Value = "" ' Pas de borne pour voie complète
                .Cells(currentRow, 6).Value = libelleDistrict
                .Cells(currentRow, 7).Value = tourneeUnique
                .Cells(currentRow, 8).Value = secableUnique
                .Cells(currentRow, 9).Value = samediUnique
            End With
            currentRow = currentRow + 1
            
        Else
            ' 4B. VOIE INCOMPLÈTE - Calcul des bornes par parité
            '=================================================================
            ' Grouper les numéros par combinaison Tournée|Sécable|Samedi
            Dim groupes As Object
            Set groupes = CreateObject("Scripting.Dictionary")
            
            Dim numerosArray As Variant
            numerosArray = voieInfo("numeros").Keys
            
            Dim k As Long
            For k = 0 To UBound(numerosArray)
                Dim numCurrent As Long
                numCurrent = numerosArray(k)
                Dim combinaison As String
                combinaison = voieInfo("numeros")(numCurrent)
                
                If Not groupes.Exists(combinaison) Then
                    Set groupes(combinaison) = CreateObject("Scripting.Dictionary")
                    groupes(combinaison)("pairs") = CreateObject("Scripting.Dictionary")
                    groupes(combinaison)("impairs") = CreateObject("Scripting.Dictionary")
                End If
                
                ' Séparer pairs et impairs
                If numCurrent Mod 2 = 0 Then
                    groupes(combinaison)("pairs")(numCurrent) = True
                Else
                    groupes(combinaison)("impairs")(numCurrent) = True
                End If
            Next k
            
            ' Traiter chaque groupe
            Dim groupesArray As Variant
            groupesArray = groupes.Keys
            
            For k = 0 To UBound(groupesArray)
                Dim groupeKey As String
                groupeKey = groupesArray(k)
                
                ' Extraire Tournée, Sécable, Samedi de la combinaison
                Dim parts As Variant
                parts = Split(groupeKey, "|")
                Dim tourneeGroupe As String, secableGroupe As String, samediGroupe As String
                tourneeGroupe = parts(0)
                secableGroupe = IIf(UBound(parts) >= 1, parts(1), "")
                samediGroupe = IIf(UBound(parts) >= 2, parts(2), "")
                
                ' Traiter les pairs
                If groupes(groupeKey)("pairs").Count > 0 Then
                    Dim paitsArray As Variant
                    paitsArray = groupes(groupeKey)("pairs").Keys
                    
                    Dim minPair As Long, maxPair As Long
                    minPair = paitsArray(0)
                    maxPair = paitsArray(0)
                    
                    Dim m As Long
                    For m = 1 To UBound(paitsArray)
                        If paitsArray(m) < minPair Then minPair = paitsArray(m)
                        If paitsArray(m) > maxPair Then maxPair = paitsArray(m)
                    Next m
                    
                    ' Écrire la ligne pour les pairs
                    With wsCalcul
                        .Cells(currentRow, 1).Value = commune
                        .Cells(currentRow, 2).Value = motDirecteur
                        .Cells(currentRow, 3).Value = voie
                        .Cells(currentRow, 4).Value = ligne3
                        .Cells(currentRow, 5).Value = minPair & " → " & maxPair
                        .Cells(currentRow, 6).Value = libelleDistrict
                        .Cells(currentRow, 7).Value = tourneeGroupe
                        .Cells(currentRow, 8).Value = secableGroupe
                        .Cells(currentRow, 9).Value = samediGroupe
                    End With
                    currentRow = currentRow + 1
                End If
                
                ' Traiter les impairs
                If groupes(groupeKey)("impairs").Count > 0 Then
                    Dim impairsArray As Variant
                    impairsArray = groupes(groupeKey)("impairs").Keys
                    
                    Dim minImpair As Long, maxImpair As Long
                    minImpair = impairsArray(0)
                    maxImpair = impairsArray(0)
                    
                    For m = 1 To UBound(impairsArray)
                        If impairsArray(m) < minImpair Then minImpair = impairsArray(m)
                        If impairsArray(m) > maxImpair Then maxImpair = impairsArray(m)
                    Next m
                    
                    ' Écrire la ligne pour les impairs
                    With wsCalcul
                        .Cells(currentRow, 1).Value = commune
                        .Cells(currentRow, 2).Value = motDirecteur
                        .Cells(currentRow, 3).Value = voie
                        .Cells(currentRow, 4).Value = ligne3
                        .Cells(currentRow, 5).Value = minImpair & " → " & maxImpair
                        .Cells(currentRow, 6).Value = libelleDistrict
                        .Cells(currentRow, 7).Value = tourneeGroupe
                        .Cells(currentRow, 8).Value = secableGroupe
                        .Cells(currentRow, 9).Value = samediGroupe
                    End With
                    currentRow = currentRow + 1
                End If
            Next k
        End If
    Next j
    
    ' 5. MISE EN FORME FINALE
    '=========================================================================
    With wsCalcul
        ' Ajuster la largeur des colonnes
        .Columns("A:I").AutoFit
        
        ' Ajouter des bordures
        .Range("A1:I" & (currentRow - 1)).Borders.LineStyle = xlContinuous
        
        ' Centrer les en-têtes
        .Range("A1:I1").HorizontalAlignment = xlCenter
        
        ' Aller à la cellule A1
        .Range("A1").Select
    End With
    
    ' Message de confirmation
    MsgBox "Calcul des bornes terminé avec succès !" & vbCrLf & _
           "Nombre de voies traitées : " & voiesData.Count & vbCrLf & _
           "Lignes générées : " & (currentRow - 2), vbInformation
    
    Exit Sub
    
ErrorHandler:
    Application.DisplayAlerts = True
    MsgBox "Erreur lors du calcul des bornes : " & Err.Description, vbCritical
End Sub
