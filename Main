Sub CalculerBornes()
    On Error GoTo ErrorHandler
    
    Dim wsSource As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim resultRow As Long
    
    ' Collections pour stocker les données groupées
    Dim dictGroups As Object
    Set dictGroups = CreateObject("Scripting.Dictionary")
    
    ' Variables pour les données de chaque ligne
    Dim tournee As String, libelleDistrict As String, ligne3 As String
    Dim numero As String, motDirecteur As String, voie As String
    Dim commune As String, secable As String, samedi As String
    Dim groupKey As String, numeroInt As Long
    
    ' 1. Identifier la feuille source (première feuille du classeur)
    Set wsSource = ThisWorkbook.Worksheets(1)
    
    ' 2. Supprimer la feuille "Calcul des bornes" si elle existe
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    ' 3. Créer la nouvelle feuille "Calcul des bornes"
    Set wsResult = ThisWorkbook.Worksheets.Add
    wsResult.Name = "Calcul des bornes"
    
    ' 4. Créer les en-têtes
    With wsResult
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Formatage des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(220, 220, 220)
    End With
    
    ' 5. Lire les données et les regrouper
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    For i = 2 To lastRow ' Commencer à la ligne 2 (après les en-têtes)
        ' Lire les données de la ligne courante
        tournee = Trim(CStr(wsSource.Cells(i, 1).Value))
        libelleDistrict = Trim(CStr(wsSource.Cells(i, 2).Value))
        ligne3 = Trim(CStr(wsSource.Cells(i, 3).Value))
        numero = Trim(CStr(wsSource.Cells(i, 4).Value))
        motDirecteur = Trim(CStr(wsSource.Cells(i, 5).Value))
        voie = Trim(CStr(wsSource.Cells(i, 6).Value))
        commune = Trim(CStr(wsSource.Cells(i, 7).Value))
        secable = Trim(CStr(wsSource.Cells(i, 8).Value))
        samedi = Trim(CStr(wsSource.Cells(i, 9).Value))
        
        ' Ignorer les lignes avec numéro vide ou non numérique
        If numero <> "" And IsNumeric(numero) Then
            numeroInt = CLng(numero)
            
            ' Clé de regroupement : Commune + Mot Directeur + Voie
            groupKey = commune & "|" & motDirecteur & "|" & voie
            
            ' Initialiser le groupe s'il n'existe pas
            If Not dictGroups.Exists(groupKey) Then
                Set dictGroups(groupKey) = CreateObject("Scripting.Dictionary")
                dictGroups(groupKey)("commune") = commune
                dictGroups(groupKey)("motDirecteur") = motDirecteur
                dictGroups(groupKey)("voie") = voie
                dictGroups(groupKey)("ligne3") = ligne3
                dictGroups(groupKey)("libelleDistrict") = libelleDistrict
                Set dictGroups(groupKey)("adresses") = CreateObject("Scripting.Dictionary")
            End If
            
            ' Ajouter l'adresse au groupe
            Dim adresseKey As String
            adresseKey = tournee & "|" & secable & "|" & samedi & "|" & CStr(numeroInt)
            
            If Not dictGroups(groupKey)("adresses").Exists(adresseKey) Then
                Set dictGroups(groupKey)("adresses")(adresseKey) = CreateObject("Scripting.Dictionary")
                dictGroups(groupKey)("adresses")(adresseKey)("tournee") = tournee
                dictGroups(groupKey)("adresses")(adresseKey)("secable") = secable
                dictGroups(groupKey)("adresses")(adresseKey)("samedi") = samedi
                dictGroups(groupKey)("adresses")(adresseKey)("numero") = numeroInt
            End If
        End If
    Next i
    
    ' 6. Traiter chaque groupe
    resultRow = 2
    Dim groupKeys As Variant
    groupKeys = dictGroups.Keys
    
    For i = 0 To UBound(groupKeys)
        Dim currentGroup As Object
        Set currentGroup = dictGroups(groupKeys(i))
        
        ' Vérifier si la voie est complète
        If EstVoieComplete(currentGroup("adresses")) Then
            ' Voie complète : une seule ligne sans borne
            Dim premierAdresse As Object
            Set premierAdresse = currentGroup("adresses")(currentGroup("adresses").Keys()(0))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), "", _
                currentGroup("libelleDistrict"), premierAdresse("tournee"), _
                premierAdresse("secable"), premierAdresse("samedi")
            resultRow = resultRow + 1
        Else
            ' Voie non complète : calculer les bornes
            CalculerEtEcrireBornes currentGroup, wsResult, resultRow
        End If
    Next i
    
    ' 7. Ajuster la largeur des colonnes
    wsResult.Columns("A:I").AutoFit
    
    MsgBox "Calcul des bornes terminé. " & (resultRow - 2) & " lignes générées.", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur : " & Err.Description, vbCritical
End Sub

' Fonction pour vérifier si une voie est complète
Private Function EstVoieComplete(adresses As Object) As Boolean
    Dim keys As Variant
    keys = adresses.Keys
    
    If UBound(keys) < 0 Then
        EstVoieComplete = True
        Exit Function
    End If
    
    ' Obtenir les valeurs de référence (première adresse)
    Dim refTournee As String, refSecable As String, refSamedi As String
    Dim premierAdresse As Object
    Set premierAdresse = adresses(keys(0))
    refTournee = premierAdresse("tournee")
    refSecable = premierAdresse("secable")
    refSamedi = premierAdresse("samedi")
    
    ' Vérifier que toutes les adresses ont les mêmes valeurs
    Dim j As Long
    For j = 0 To UBound(keys)
        Dim currentAdresse As Object
        Set currentAdresse = adresses(keys(j))
        
        If currentAdresse("tournee") <> refTournee Or _
           currentAdresse("secable") <> refSecable Or _
           currentAdresse("samedi") <> refSamedi Then
            EstVoieComplete = False
            Exit Function
        End If
    Next j
    
    EstVoieComplete = True
End Function

' Subroutine pour calculer et écrire les bornes
Private Sub CalculerEtEcrireBornes(currentGroup As Object, wsResult As Worksheet, ByRef resultRow As Long)
    ' Regrouper par Tournée + Sécable + Samedi
    Dim dictSubGroups As Object
    Set dictSubGroups = CreateObject("Scripting.Dictionary")
    
    Dim adresseKeys As Variant
    adresseKeys = currentGroup("adresses").Keys
    
    Dim j As Long
    For j = 0 To UBound(adresseKeys)
        Dim currentAdresse As Object
        Set currentAdresse = currentGroup("adresses")(adresseKeys(j))
        
        Dim subGroupKey As String
        subGroupKey = currentAdresse("tournee") & "|" & currentAdresse("secable") & "|" & currentAdresse("samedi")
        
        If Not dictSubGroups.Exists(subGroupKey) Then
            Set dictSubGroups(subGroupKey) = CreateObject("Scripting.Dictionary")
            dictSubGroups(subGroupKey)("tournee") = currentAdresse("tournee")
            dictSubGroups(subGroupKey)("secable") = currentAdresse("secable")
            dictSubGroups(subGroupKey)("samedi") = currentAdresse("samedi")
            dictSubGroups(subGroupKey)("pairs") = New Collection
            dictSubGroups(subGroupKey)("impairs") = New Collection
        End If
        
        ' Séparer pairs et impairs
        If currentAdresse("numero") Mod 2 = 0 Then
            dictSubGroups(subGroupKey)("pairs").Add currentAdresse("numero")
        Else
            dictSubGroups(subGroupKey)("impairs").Add currentAdresse("numero")
        End If
    Next j
    
    ' Écrire les bornes pour chaque sous-groupe
    Dim subGroupKeys As Variant
    subGroupKeys = dictSubGroups.Keys
    
    For j = 0 To UBound(subGroupKeys)
        Dim currentSubGroup As Object
        Set currentSubGroup = dictSubGroups(subGroupKeys(j))
        
        ' Traiter les pairs
        If currentSubGroup("pairs").Count > 0 Then
            Dim bornePairs As String
            bornePairs = CalculerBorne(currentSubGroup("pairs"))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), bornePairs, _
                currentGroup("libelleDistrict"), currentSubGroup("tournee"), _
                currentSubGroup("secable"), currentSubGroup("samedi")
            resultRow = resultRow + 1
        End If
        
        ' Traiter les impairs
        If currentSubGroup("impairs").Count > 0 Then
            Dim borneImpairs As String
            borneImpairs = CalculerBorne(currentSubGroup("impairs"))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), borneImpairs, _
                currentGroup("libelleDistrict"), currentSubGroup("tournee"), _
                currentSubGroup("secable"), currentSubGroup("samedi")
            resultRow = resultRow + 1
        End If
    Next j
End Sub

' Fonction pour calculer une borne à partir d'une collection de numéros
Private Function CalculerBorne(numeros As Collection) As String
    If numeros.Count = 0 Then
        CalculerBorne = ""
        Exit Function
    End If
    
    ' Convertir en tableau et trier
    Dim arr() As Long
    ReDim arr(1 To numeros.Count)
    
    Dim i As Long
    For i = 1 To numeros.Count
        arr(i) = numeros(i)
    Next i
    
    ' Tri simple (bulle sort)
    Dim j As Long, temp As Long
    For i = 1 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
    
    ' Retourner la borne formatée
    If UBound(arr) = 1 Then
        CalculerBorne = CStr(arr(1))
    Else
        CalculerBorne = CStr(arr(1)) & " → " & CStr(arr(UBound(arr)))
    End If
End Function

' Subroutine pour écrire une ligne de résultat
Private Sub EcrireLigneResultat(ws As Worksheet, row As Long, _
    commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, borne As String, libelleDistrict As String, _
    tournee As String, secable As String, samedi As String)
    
    With ws
        .Cells(row, 1).Value = commune
        .Cells(row, 2).Value = motDirecteur
        .Cells(row, 3).Value = voie
        .Cells(row, 4).Value = ligne3
        .Cells(row, 5).Value = borne
        .Cells(row, 6).Value = libelleDistrict
        .Cells(row, 7).Value = tournee
        .Cells(row, 8).Value = secable
        .Cells(row, 9).Value = samedi
    End With
End Sub
