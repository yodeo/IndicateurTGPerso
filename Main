Sub CalculerBornes()
    '=========================================================================
    ' VERSION DEBUG DÉTAILLÉ POUR IDENTIFIER LE PROBLÈME
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim debugInfo As String
    
    On Error GoTo ErrorHandler
    
    debugInfo = "=== DEBUG DÉTAILLÉ ===" & vbCrLf
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Set ws = Nothing
    Dim wsTemp As Worksheet
    
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name <> "Calcul des bornes" Then
            On Error Resume Next
            Dim h1 As String, h4 As String, h6 As String, h7 As String
            h1 = wsTemp.Cells(1, 1).Value
            h4 = wsTemp.Cells(1, 4).Value
            h6 = wsTemp.Cells(1, 6).Value
            h7 = wsTemp.Cells(1, 7).Value
            On Error GoTo ErrorHandler
            
            If (h1 Like "*ournée*" Or h1 Like "*ourn*" Or h1 = "Tournée") And _
               (h4 Like "*uméro*" Or h4 Like "*um*" Or h4 = "Numéro") And _
               (h6 Like "*oie*" Or h6 = "Voie") And _
               (h7 Like "*ommune*" Or h7 = "Commune") Then
                Set ws = wsTemp
                Exit For
            End If
        End If
    Next wsTemp
    
    If ws Is Nothing Then
        MsgBox "Feuille source non trouvée !", vbCritical
        Exit Sub
    End If
    
    debugInfo = debugInfo & "Feuille source: " & ws.Name & vbCrLf
    
    ' 2. CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' En-têtes
    With wsCalcul
        .Cells(1, 1) = "Commune"
        .Cells(1, 2) = "Mot directeur"
        .Cells(1, 3) = "Libelle de voie"
        .Cells(1, 4) = "Ligne 3"
        .Cells(1, 5) = "Numéro de voie (borne)"
        .Cells(1, 6) = "Libelle District"
        .Cells(1, 7) = "Tournée"
        .Cells(1, 8) = "Sécable"
        .Cells(1, 9) = "Samedi"
        
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(180, 198, 231)
    End With
    
    ' 3. ANALYSE DES DONNÉES
    '=========================================================================
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    debugInfo = debugInfo & "Dernière ligne: " & lastRow & vbCrLf
    
    Dim voiesUniques As Object
    Set voiesUniques = CreateObject("Scripting.Dictionary")
    
    ' Identifier toutes les voies uniques
    Dim i As Long
    For i = 2 To lastRow
        On Error Resume Next
        Dim commune As String, voie As String, motDirecteur As String
        commune = Trim(CStr(ws.Cells(i, 7).Value))
        voie = Trim(CStr(ws.Cells(i, 6).Value))
        motDirecteur = Trim(CStr(ws.Cells(i, 5).Value))
        On Error GoTo ErrorHandler
        
        If commune <> "" And voie <> "" Then
            Dim cleVoie As String
            cleVoie = commune & "###" & voie & "###" & motDirecteur
            
            If Not voiesUniques.Exists(cleVoie) Then
                voiesUniques(cleVoie) = True
            End If
        End If
    Next i
    
    debugInfo = debugInfo & "Voies uniques trouvées: " & voiesUniques.Count & vbCrLf
    
    ' 4. TEST SUR LES 3 PREMIÈRES VOIES AVEC DEBUG DÉTAILLÉ
    '=========================================================================
    Dim ligneResultat As Long
    ligneResultat = 2
    
    Dim voiesKeys As Variant
    voiesKeys = voiesUniques.Keys
    
    ' Traiter seulement les 3 premières voies pour le debug
    Dim nbVoiesATester As Long
    nbVoiesATester = WorksheetFunction.Min(3, UBound(voiesKeys) + 1)
    
    debugInfo = debugInfo & vbCrLf & "=== TEST SUR " & nbVoiesATester & " PREMIÈRES VOIES ===" & vbCrLf
    
    For i = 0 To nbVoiesATester - 1
        debugInfo = debugInfo & vbCrLf & "--- TRAITEMENT VOIE " & (i + 1) & " ---" & vbCrLf
        debugInfo = debugInfo & "Clé: " & voiesKeys(i) & vbCrLf
        
        Call TraiterVoieDebugDetaille(voiesKeys(i), ws, wsCalcul, ligneResultat, debugInfo)
    Next i
    
    Dim nbResultats As Long
    nbResultats = ligneResultat - 2
    
    ' 5. MISE EN FORME ET RÉSULTAT
    '=========================================================================
    With wsCalcul
        .Columns("A:I").AutoFit
        If nbResultats > 0 Then
            .Range("A1:I" & ligneResultat - 1).Borders.LineStyle = xlContinuous
        End If
        .Range("A1:I1").HorizontalAlignment = xlCenter
        .Range("A1").Select
    End With
    
    debugInfo = debugInfo & vbCrLf & "=== RÉSULTAT FINAL ===" & vbCrLf
    debugInfo = debugInfo & "Lignes de résultat générées: " & nbResultats & vbCrLf
    
    MsgBox debugInfo, vbInformation
    
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur: " & Err.Description & " (Ligne " & Erl & ")" & vbCrLf & vbCrLf & debugInfo, vbCritical
End Sub

Sub TraiterVoieDebugDetaille(ByVal cleVoie As String, ByRef ws As Worksheet, ByRef wsCalcul As Worksheet, ByRef ligneResultat As Long, ByRef debugInfo As String)
    
    ' Extraire les informations de la clé
    Dim parts As Variant
    parts = Split(cleVoie, "###")
    If UBound(parts) < 2 Then
        debugInfo = debugInfo & "ERREUR: Clé invalide" & vbCrLf
        Exit Sub
    End If
    
    Dim commune As String, voie As String, motDirecteur As String
    commune = parts(0)
    voie = parts(1)
    motDirecteur = parts(2)
    
    debugInfo = debugInfo & "Commune: [" & commune & "]" & vbCrLf
    debugInfo = debugInfo & "Voie: [" & voie & "]" & vbCrLf
    debugInfo = debugInfo & "Mot Directeur: [" & motDirecteur & "]" & vbCrLf
    
    ' Collecter toutes les lignes de cette voie
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    Dim lignesCorrespondantes As Long
    lignesCorrespondantes = 0
    
    ' Variables de référence
    Dim ligne3 As String, libelleDistrict As String
    Dim premiereIteration As Boolean
    premiereIteration = True
    
    ' Dictionnaire pour regrouper par combinaison
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    For i = 2 To lastRow
        On Error Resume Next
        Dim communeLigne As String, voieLigne As String, motDirecteurLigne As String
        communeLigne = Trim(CStr(ws.Cells(i, 7).Value))
        voieLigne = Trim(CStr(ws.Cells(i, 6).Value))
        motDirecteurLigne = Trim(CStr(ws.Cells(i, 5).Value))
        
        If Err.Number <> 0 Then
            debugInfo = debugInfo & "Erreur lecture ligne " & i & ": " & Err.Description & vbCrLf
            On Error GoTo 0
            GoTo NextLine
        End If
        On Error GoTo 0
        
        If communeLigne = commune And voieLigne = voie And motDirecteurLigne = motDirecteur Then
            lignesCorrespondantes = lignesCorrespondantes + 1
            
            ' Première ligne : récupérer les valeurs de référence
            If premiereIteration Then
                On Error Resume Next
                ligne3 = Trim(CStr(ws.Cells(i, 3).Value))
                libelleDistrict = Trim(CStr(ws.Cells(i, 2).Value))
                On Error GoTo 0
                premiereIteration = False
                
                debugInfo = debugInfo & "Ligne 3: [" & ligne3 & "]" & vbCrLf
                debugInfo = debugInfo & "Libellé District: [" & libelleDistrict & "]" & vbCrLf
            End If
            
            ' Lire les données de distribution
            On Error Resume Next
            Dim tournee As String, secable As String, samedi As String
            tournee = Trim(CStr(ws.Cells(i, 1).Value))
            secable = Trim(CStr(ws.Cells(i, 8).Value))
            samedi = Trim(CStr(ws.Cells(i, 9).Value))
            
            If Err.Number <> 0 Then
                debugInfo = debugInfo & "Erreur lecture distribution ligne " & i & ": " & Err.Description & vbCrLf
                On Error GoTo 0
                GoTo NextLine
            End If
            On Error GoTo 0
            
            ' Créer la clé de groupe
            Dim cleGroupe As String
            cleGroupe = tournee & "|" & secable & "|" & samedi
            
            ' Initialiser le groupe si nécessaire
            If Not groupes.Exists(cleGroupe) Then
                Dim nouveauGroupe As Object
                Set nouveauGroupe = CreateObject("Scripting.Dictionary")
                nouveauGroupe("tournee") = tournee
                nouveauGroupe("secable") = secable
                nouveauGroupe("samedi") = samedi
                nouveauGroupe("pairs") = New Collection
                nouveauGroupe("impairs") = New Collection
                groupes(cleGroupe) = nouveauGroupe
                
                debugInfo = debugInfo & "Nouveau groupe: [" & cleGroupe & "]" & vbCrLf
            End If
            
            ' Ajouter le numéro selon sa parité
            Dim numero As Variant
            numero = ws.Cells(i, 4).Value
            If IsNumeric(numero) And numero > 0 Then
                Dim numInt As Long
                numInt = CLng(numero)
                
                If numInt Mod 2 = 0 Then
                    groupes(cleGroupe)("pairs").Add numInt
                    debugInfo = debugInfo & "Ajout pair: " & numInt & " au groupe [" & cleGroupe & "]" & vbCrLf
                Else
                    groupes(cleGroupe)("impairs").Add numInt
                    debugInfo = debugInfo & "Ajout impair: " & numInt & " au groupe [" & cleGroupe & "]" & vbCrLf
                End If
            Else
                debugInfo = debugInfo & "Numéro ignoré ligne " & i & ": [" & numero & "]" & vbCrLf
            End If
        End If
        
NextLine:
    Next i
    
    debugInfo = debugInfo & "Lignes correspondantes trouvées: " & lignesCorrespondantes & vbCrLf
    debugInfo = debugInfo & "Groupes créés: " & groupes.Count & vbCrLf
    
    If groupes.Count = 0 Then
        debugInfo = debugInfo & "PROBLÈME: Aucun groupe créé pour cette voie !" & vbCrLf
        Exit Sub
    End If
    
    ' Déterminer si la voie est complète
    Dim estComplete As Boolean
    estComplete = (groupes.Count = 1)
    debugInfo = debugInfo & "Voie complète: " & estComplete & vbCrLf
    
    ' Générer les lignes de résultat
    Dim groupesKeys As Variant
    groupesKeys = groupes.Keys
    
    Dim g As Long
    For g = 0 To UBound(groupesKeys)
        Dim groupeKey As String
        groupeKey = groupesKeys(g)
        
        Dim groupe As Object
        Set groupe = groupes(groupeKey)
        
        debugInfo = debugInfo & "Traitement groupe: [" & groupeKey & "]" & vbCrLf
        debugInfo = debugInfo & "- Pairs: " & groupe("pairs").Count & vbCrLf
        debugInfo = debugInfo & "- Impairs: " & groupe("impairs").Count & vbCrLf
        
        If estComplete Then
            ' Voie complète : une ligne sans borne
            With wsCalcul
                .Cells(ligneResultat, 1) = commune
                .Cells(ligneResultat, 2) = motDirecteur
                .Cells(ligneResultat, 3) = voie
                .Cells(ligneResultat, 4) = ligne3
                .Cells(ligneResultat, 5) = "" ' Pas de borne
                .Cells(ligneResultat, 6) = libelleDistrict
                .Cells(ligneResultat, 7) = groupe("tournee")
                .Cells(ligneResultat, 8) = groupe("secable")
                .Cells(ligneResultat, 9) = groupe("samedi")
            End With
            ligneResultat = ligneResultat + 1
            debugInfo = debugInfo & "→ Ligne voie complète écrite (ligne " & (ligneResultat - 1) & ")" & vbCrLf
            
        Else
            ' Voie incomplète : bornes par parité
            
            ' Traiter les pairs
            If groupe("pairs").Count > 0 Then
                Dim minPair As Long, maxPair As Long
                Call TrouverMinMaxCollection(groupe("pairs"), minPair, maxPair)
                
                With wsCalcul
                    .Cells(ligneResultat, 1) = commune
                    .Cells(ligneResultat, 2) = motDirecteur
                    .Cells(ligneResultat, 3) = voie
                    .Cells(ligneResultat, 4) = ligne3
                    .Cells(ligneResultat, 5) = minPair & " → " & maxPair
                    .Cells(ligneResultat, 6) = libelleDistrict
                    .Cells(ligneResultat, 7) = groupe("tournee")
                    .Cells(ligneResultat, 8) = groupe("secable")
                    .Cells(ligneResultat, 9) = groupe("samedi")
                End With
                ligneResultat = ligneResultat + 1
                debugInfo = debugInfo & "→ Ligne pairs écrite: " & minPair & " → " & maxPair & " (ligne " & (ligneResultat - 1) & ")" & vbCrLf
            End If
            
            ' Traiter les impairs
            If groupe("impairs").Count > 0 Then
                Dim minImpair As Long, maxImpair As Long
                Call TrouverMinMaxCollection(groupe("impairs"), minImpair, maxImpair)
                
                With wsCalcul
                    .Cells(ligneResultat, 1) = commune
                    .Cells(ligneResultat, 2) = motDirecteur
                    .Cells(ligneResultat, 3) = voie
                    .Cells(ligneResultat, 4) = ligne3
                    .Cells(ligneResultat, 5) = minImpair & " → " & maxImpair
                    .Cells(ligneResultat, 6) = libelleDistrict
                    .Cells(ligneResultat, 7) = groupe("tournee")
                    .Cells(ligneResultat, 8) = groupe("secable")
                    .Cells(ligneResultat, 9) = groupe("samedi")
                End With
                ligneResultat = ligneResultat + 1
                debugInfo = debugInfo & "→ Ligne impairs écrite: " & minImpair & " → " & maxImpair & " (ligne " & (ligneResultat - 1) & ")" & vbCrLf
            End If
        End If
    Next g
End Sub

Sub TrouverMinMaxCollection(ByRef col As Collection, ByRef minVal As Long, ByRef maxVal As Long)
    If col.Count = 0 Then Exit Sub
    
    minVal = col(1)
    maxVal = col(1)
    
    Dim i As Long
    For i = 2 To col.Count
        If col(i) < minVal Then minVal = col(i)
        If col(i) > maxVal Then maxVal = col(i)
    Next i
End Sub
