Sub CalculerBornes()
    '=========================================================================
    ' VERSION OPTIMISÉE POUR LA VITESSE - MÊME RÉSULTAT FINAL
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim lastRow As Long
    Dim dataArray As Variant
    Dim resultData() As Variant
    Dim resultCount As Long
    
    ' Optimisations Excel
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Set ws = Nothing
    Dim wsTemp As Worksheet
    
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name <> "Calcul des bornes" Then
            Dim h1 As String, h4 As String, h6 As String, h7 As String
            h1 = SafeValue(wsTemp.Cells(1, 1).Value)
            h4 = SafeValue(wsTemp.Cells(1, 4).Value)
            h6 = SafeValue(wsTemp.Cells(1, 6).Value)
            h7 = SafeValue(wsTemp.Cells(1, 7).Value)
            
            If (InStr(UCase(h1), "TOURN") > 0) And _
               (InStr(UCase(h4), "NUM") > 0) And _
               (InStr(UCase(h6), "VOIE") > 0) And _
               (InStr(UCase(h7), "COMM") > 0) Then
                Set ws = wsTemp
                Exit For
            End If
        End If
    Next wsTemp
    
    If ws Is Nothing Then
        MsgBox "Feuille source non trouvée !", vbCritical
        GoTo CleanUp
    End If
    
    ' 2. LECTURE MASSIVE DES DONNÉES
    '=========================================================================
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    If lastRow < 2 Then
        MsgBox "Aucune donnée trouvée.", vbExclamation
        GoTo CleanUp
    End If
    
    ' Lire toutes les données d'un coup (beaucoup plus rapide)
    dataArray = ws.Range("A2:I" & lastRow).Value
    
    ' 3. CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    Application.DisplayAlerts = False
    Set wsCalcul = Nothing
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name = "Calcul des bornes" Then
            wsTemp.Delete
            Exit For
        End If
    Next wsTemp
    Application.DisplayAlerts = True
    
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' En-têtes
    Dim headers As Variant
    headers = Array("Commune", "Mot directeur", "Libelle de voie", "Ligne 3", _
                   "Numéro de voie (borne)", "Libelle District", "Tournée", "Sécable", "Samedi")
    wsCalcul.Range("A1:I1").Value = headers
    wsCalcul.Range("A1:I1").Font.Bold = True
    wsCalcul.Range("A1:I1").Interior.Color = RGB(180, 198, 231)
    
    ' 4. TRAITEMENT OPTIMISÉ AVEC DICTIONNAIRE
    '=========================================================================
    Dim voiesDict As Object
    Set voiesDict = CreateObject("Scripting.Dictionary")
    
    ' Une seule passe pour regrouper toutes les données par voie
    Dim i As Long
    For i = 1 To UBound(dataArray, 1)
        Dim commune As String, voie As String, motDirecteur As String
        commune = SafeValue(dataArray(i, 7))  ' Colonne G - Commune
        voie = SafeValue(dataArray(i, 6))     ' Colonne F - Voie
        motDirecteur = SafeValue(dataArray(i, 5)) ' Colonne E - Mot Directeur
        
        If commune <> "" And voie <> "" Then
            Dim cleVoie As String
            cleVoie = commune & "§" & voie
            
            ' Initialiser la voie si première fois
            If Not voiesDict.Exists(cleVoie) Then
                Dim voieInfo As Object
                Set voieInfo = CreateObject("Scripting.Dictionary")
                voieInfo("commune") = commune
                voieInfo("voie") = voie
                voieInfo("motDirecteur") = motDirecteur
                voieInfo("ligne3") = SafeValue(dataArray(i, 3))
                voieInfo("libelleDistrict") = SafeValue(dataArray(i, 2))
                voieInfo("lignes") = Array()
                voiesDict(cleVoie) = voieInfo
            End If
            
            ' Ajouter cette ligne aux données de la voie
            Dim ligneData As Object
            Set ligneData = CreateObject("Scripting.Dictionary")
            ligneData("tournee") = SafeValue(dataArray(i, 1))
            ligneData("secable") = SafeValue(dataArray(i, 8))
            ligneData("samedi") = SafeValue(dataArray(i, 9))
            ligneData("numero") = dataArray(i, 4) ' Garder la valeur brute pour IsNumeric
            
            ' Ajouter à la collection des lignes
            Dim lignesExistantes As Variant
            lignesExistantes = voiesDict(cleVoie)("lignes")
            ReDim Preserve lignesExistantes(UBound(lignesExistantes) + 1)
            Set lignesExistantes(UBound(lignesExistantes)) = ligneData
            voiesDict(cleVoie)("lignes") = lignesExistantes
        End If
    Next i
    
    ' 5. TRAITEMENT DE CHAQUE VOIE ET GÉNÉRATION DES RÉSULTATS
    '=========================================================================
    ReDim resultData(1 To voiesDict.Count * 5, 1 To 9) ' Prévoir large
    resultCount = 0
    
    Dim voiesKeys As Variant
    voiesKeys = voiesDict.Keys
    
    For i = 0 To UBound(voiesKeys)
        Dim voieKey As String
        voieKey = voiesKeys(i)
        Dim voie As Object
        Set voie = voiesDict(voieKey)
        
        Call TraiterVoieRapide(voie, resultData, resultCount)
    Next i
    
    ' 6. ÉCRITURE MASSIVE DES RÉSULTATS
    '=========================================================================
    If resultCount > 0 Then
        ' Redimensionner le tableau aux bonnes dimensions
        ReDim Preserve resultData(1 To resultCount, 1 To 9)
        
        ' Écrire tout d'un coup (beaucoup plus rapide)
        wsCalcul.Range("A2").Resize(resultCount, 9).Value = resultData
        
        ' Mise en forme
        With wsCalcul
            .Columns("A:I").AutoFit
            .Range("A1:I" & (resultCount + 1)).Borders.LineStyle = xlContinuous
            .Range("A1:I1").HorizontalAlignment = xlCenter
            .Range("A1").Select
        End With
    End If
    
    MsgBox "Calcul terminé !" & vbCrLf & "Lignes générées: " & resultCount, vbInformation
    
CleanUp:
    ' Restaurer les paramètres Excel
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.DisplayAlerts = True
End Sub

Function SafeValue(ByVal cellValue As Variant) As String
    ' Fonction ultra-rapide pour convertir une valeur
    If IsEmpty(cellValue) Or IsNull(cellValue) Or IsError(cellValue) Then
        SafeValue = ""
    Else
        SafeValue = Trim(CStr(cellValue))
    End If
End Function

Sub TraiterVoieRapide(ByRef voie As Object, ByRef resultData As Variant, ByRef resultCount As Long)
    ' Traitement optimisé d'une voie
    
    Dim lignes As Variant
    lignes = voie("lignes")
    
    If UBound(lignes) < 0 Then Exit Sub ' Pas de lignes
    
    ' Dictionnaires pour regrouper par combinaison
    Dim combinaisonsDict As Object
    Set combinaisonsDict = CreateObject("Scripting.Dictionary")
    
    ' Analyser toutes les lignes de cette voie
    Dim i As Long
    For i = 0 To UBound(lignes)
        Dim ligne As Object
        Set ligne = lignes(i)
        
        Dim numero As Variant
        numero = ligne("numero")
        
        ' Traiter seulement les numéros valides
        If IsNumeric(numero) And numero > 0 Then
            Dim numInt As Long
            numInt = CLng(numero)
            
            Dim combinaison As String
            combinaison = ligne("tournee") & "|" & ligne("secable") & "|" & ligne("samedi")
            
            ' Initialiser la combinaison si première fois
            If Not combinaisonsDict.Exists(combinaison) Then
                Dim comboInfo As Object
                Set comboInfo = CreateObject("Scripting.Dictionary")
                comboInfo("tournee") = ligne("tournee")
                comboInfo("secable") = ligne("secable")
                comboInfo("samedi") = ligne("samedi")
                comboInfo("pairs") = Array()
                comboInfo("impairs") = Array()
                combinaisonsDict(combinaison) = comboInfo
            End If
            
            ' Ajouter le numéro selon sa parité
            Dim combo As Object
            Set combo = combinaisonsDict(combinaison)
            
            If numInt Mod 2 = 0 Then
                ' Numéro pair
                Dim pairs As Variant
                pairs = combo("pairs")
                ReDim Preserve pairs(UBound(pairs) + 1)
                pairs(UBound(pairs)) = numInt
                combo("pairs") = pairs
            Else
                ' Numéro impair
                Dim impairs As Variant
                impairs = combo("impairs")
                ReDim Preserve impairs(UBound(impairs) + 1)
                impairs(UBound(impairs)) = numInt
                combo("impairs") = impairs
            End If
        End If
    Next i
    
    ' Générer les lignes de résultat
    If combinaisonsDict.Count = 0 Then Exit Sub ' Pas de numéros valides
    
    ' Déterminer si voie complète
    Dim estComplete As Boolean
    estComplete = (combinaisonsDict.Count = 1)
    
    Dim combKeys As Variant
    combKeys = combinaisonsDict.Keys
    
    For i = 0 To UBound(combKeys)
        Dim combKey As String
        combKey = combKeys(i)
        Dim comb As Object
        Set comb = combinaisonsDict(combKey)
        
        Dim pairsArray As Variant, impairsArray As Variant
        pairsArray = comb("pairs")
        impairsArray = comb("impairs")
        
        Dim bornePairs As String, borneImpairs As String
        bornePairs = ""
        borneImpairs = ""
        
        ' Calculer borne pairs
        If UBound(pairsArray) >= 0 Then
            Dim minPair As Long, maxPair As Long
            Call TrouverMinMaxArray(pairsArray, minPair, maxPair)
            If minPair = maxPair Then
                bornePairs = CStr(minPair)
            Else
                bornePairs = minPair & " à " & maxPair
            End If
        End If
        
        ' Calculer borne impairs
        If UBound(impairsArray) >= 0 Then
            Dim minImpair As Long, maxImpair As Long
            Call TrouverMinMaxArray(impairsArray, minImpair, maxImpair)
            If minImpair = maxImpair Then
                borneImpairs = CStr(minImpair)
            Else
                borneImpairs = minImpair & " à " & maxImpair
            End If
        End If
        
        ' Construire la borne combinée
        Dim borneCombinee As String
        If borneImpairs <> "" And bornePairs <> "" Then
            borneCombinee = borneImpairs & " / " & bornePairs
        ElseIf borneImpairs <> "" Then
            borneCombinee = borneImpairs
        ElseIf bornePairs <> "" Then
            borneCombinee = bornePairs
        Else
            borneCombinee = ""
        End If
        
        ' Ajouter la ligne au résultat seulement si on a une borne
        If borneCombinee <> "" Then
            resultCount = resultCount + 1
            
            ' Voie complète = pas de borne
            If estComplete Then
                resultData(resultCount, 5) = ""
            Else
                resultData(resultCount, 5) = borneCombinee
            End If
            
            resultData(resultCount, 1) = voie("commune")
            resultData(resultCount, 2) = voie("motDirecteur")
            resultData(resultCount, 3) = voie("voie")
            resultData(resultCount, 4) = voie("ligne3")
            resultData(resultCount, 6) = voie("libelleDistrict")
            resultData(resultCount, 7) = comb("tournee")
            resultData(resultCount, 8) = comb("secable")
            resultData(resultCount, 9) = comb("samedi")
        End If
    Next i
End Sub

Sub TrouverMinMaxArray(ByRef arr As Variant, ByRef minVal As Long, ByRef maxVal As Long)
    ' Fonction rapide pour trouver min/max
    If UBound(arr) < 0 Then Exit Sub
    
    minVal = CLng(arr(0))
    maxVal = CLng(arr(0))
    
    Dim i As Long
    For i = 1 To UBound(arr)
        Dim val As Long
        val = CLng(arr(i))
        If val < minVal Then minVal = val
        If val > maxVal Then maxVal = val
    Next i
End Sub
