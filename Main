Option Explicit

' --- Globals ---
Public g_wsSrc      As Worksheet
Public g_dataArr    As Variant
Public g_colComm    As Long
Public g_colVoie    As Long
Public g_colNum     As Long
Public g_colTour    As Long
Public g_colSecable As Long
Public g_colLigne   As Long
Public g_colLigne3  As Long

' === STRUCTURES DE DONNÉES OPTIMISÉES ===
Private Type TourneeInfo
    commune As String
    voie As String
    tournee As String
    nums() As Long
    numCount As Long
    ligneText As String
    ligne3Text As String
    isMultiTournee As Boolean
End Type

' === API Windows pour mesurer le temps ===
#If VBA7 Then
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
#Else
    Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If

' === FONCTION PRINCIPALE ULTRA-OPTIMISÉE ===
Public Sub GenererIndicateurTournées()
    Dim startTime As Long
    startTime = GetTickCount
    
    Dim nbColumns As Long, mode As Long
    Dim wsOut As Worksheet
    Dim useToutSauf As Boolean
    
    ' Interface utilisateur
    nbColumns = Application.InputBox( _
        "Nombre de colonnes pour l'affichage ?" & vbCrLf & _
        "(1 = mode simple, 2+ = mode multi-colonnes)", _
        "Configuration de l'affichage", 1, Type:=1)
    
    If nbColumns < 1 Then
        MsgBox "Le nombre de colonnes doit être au moins 1.", vbExclamation
        Exit Sub
    End If

    mode = Application.InputBox( _
        "Mode d'affichage :" & vbCrLf & _
        "1 = Standard (toutes les voies)" & vbCrLf & _
        "2 = Tout sauf (masquer les voies majoritaires)", _
        "Mode d'affichage", 1, Type:=1)
    
    If mode <> 1 And mode <> 2 Then
        MsgBox "Mode invalide.", vbExclamation
        Exit Sub
    End If
    
    useToutSauf = (mode = 2)
    
    ' Optimisations Excel
    With Application
        .ScreenUpdating = False
        .Calculation = xlCalculationManual
        .EnableEvents = False
        .DisplayStatusBar = False
        .PrintCommunication = False
    End With
    
    ' Créer la feuille de sortie
    On Error Resume Next
    Application.DisplayAlerts = False
    Worksheets("indicateur de tg à vérifier").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Set wsOut = Worksheets.Add(After:=Sheets(Sheets.Count))
    wsOut.Name = "indicateur de tg à vérifier"
    
    ' Traitement principal
    ProcessDataUltraFast ActiveSheet, wsOut, nbColumns, useToutSauf
    
    ' Restaurer Excel
    With Application
        .ScreenUpdating = True
        .Calculation = xlCalculationAutomatic
        .EnableEvents = True
        .DisplayStatusBar = True
        .PrintCommunication = True
    End With
    
    Dim elapsedTime As Long
    elapsedTime = GetTickCount - startTime
    
    MsgBox "Indicateur généré avec " & nbColumns & " colonne(s) dans 'indicateur de tg à vérifier'." & _
           vbCrLf & "Temps d'exécution : " & Format(elapsedTime / 1000, "0.00") & " secondes", vbInformation
End Sub

' === TRAITEMENT PRINCIPAL ULTRA-RAPIDE ===
Private Sub ProcessDataUltraFast(wsSource As Worksheet, wsOut As Worksheet, _
                                nbColumns As Long, useToutSauf As Boolean)
    
    Dim dataArr As Variant
    Dim outputArr() As Variant
    Dim formatArr() As Variant
    Dim rowCount As Long, colCount As Long
    Dim i As Long, j As Long, outputRow As Long
    Dim totalCols As Long
    
    ' Charger toutes les données en mémoire
    Dim raw As Variant
    raw = wsSource.UsedRange.Value
    If Not IsArray(raw) Then
        ' Si une seule cellule, on crée un tableau 2D 1×1
        ReDim dataArr(1 To 1, 1 To 1)
        dataArr(1, 1) = raw
    Else
        dataArr = raw
    End If
    
    ' Maintenant on peut utiliser UBound
    rowCount = UBound(dataArr, 1)
    colCount = UBound(dataArr, 2)
    
    ' Identifier les colonnes
    Dim colMap(1 To 7) As Long
    For j = 1 To colCount
        Select Case UCase$(Trim(dataArr(1, j)))
            Case "COMMUNE":   colMap(1) = j
            Case "VOIE":      colMap(2) = j
            Case "NUMÉRO", "NUMERO": colMap(3) = j
            Case "TOURNÉE", "TOURNEE": colMap(4) = j
            Case "SÉCABLE", "SECABLE": colMap(5) = j
            Case "LIGNE":     colMap(6) = j
            Case "LIGNE 3":   colMap(7) = j
        End Select
    Next j
    
    If colMap(1) * colMap(2) * colMap(3) * colMap(4) = 0 Then
        MsgBox "Colonnes obligatoires introuvables", vbCritical
        Exit Sub
    End If
    
    ' Prétraitement : création d'une structure de données optimisée
    Dim dataDict As Object
    Set dataDict = CreateObject("Scripting.Dictionary")
    
    Dim commune As String, voie As String, tournee As String, numero As String
    Dim secable As String, ligne As String, ligne3 As String
    Dim key As Variant, keyStr As String
    
    For i = 2 To rowCount
        commune = Trim(CStr(dataArr(i, colMap(1))))
        voie    = Trim(CStr(dataArr(i, colMap(2))))
        numero  = Trim(CStr(dataArr(i, colMap(3))))
        tournee = Trim(CStr(dataArr(i, colMap(4))))
        
        If colMap(5) > 0 Then
            secable = Trim(CStr(dataArr(i, colMap(5))))
            If Len(secable) > 0 Then tournee = tournee & " (" & secable & ")"
        End If
        
        key = commune & "|" & voie & "|" & tournee
        
        If Not dataDict.Exists(key) Then
            dataDict.Add key, CreateObject("Scripting.Dictionary")
            dataDict(key)("nums")    = CreateObject("Scripting.Dictionary")
            dataDict(key)("ligne")   = ""
            dataDict(key)("ligne3")  = CreateObject("Scripting.Dictionary")
        End If
        
        If IsNumeric(numero) Then
            dataDict(key)("nums")(CLng(numero)) = True
        End If
        
        If colMap(6) > 0 Then
            ligne = Trim(CStr(dataArr(i, colMap(6))))
            If Len(ligne) > 0 And dataDict(key)("ligne") = "" Then
                dataDict(key)("ligne") = ligne
            End If
        End If
        
        If colMap(7) > 0 Then
            ligne3 = Trim(CStr(dataArr(i, colMap(7))))
            If Len(ligne3) > 0 Then
                dataDict(key)("ligne3")(ligne3) = True
            End If
        End If
    Next i
    
    ' Générer la sortie
    totalCols = nbColumns * 2
    ReDim outputArr(1 To rowCount, 1 To totalCols)
    ReDim formatArr(1 To rowCount, 1 To 5)
    
    outputRow = 0
    Dim communes As Object, voies As Object
    Set communes = CreateObject("Scripting.Dictionary")
    
    ' Regrouper par commune
    For Each key In dataDict.Keys
        Dim parts() As String
        parts = Split(CStr(key), "|")
        commune = parts(0)
        If Not communes.Exists(commune) Then
            Set communes(commune) = CreateObject("Scripting.Dictionary")
        End If
        communes(commune)(CStr(key)) = True
    Next
    
    ' Tri des communes par dernier mot
    Dim communeKeys As Variant
    communeKeys = communes.Keys
    communeKeys = QuickSortByLastWordArray(communeKeys)
    
    ' Boucle principale de création
    For Each commune In communeKeys
        outputRow = outputRow + 1
        outputArr(outputRow, 1) = commune
        formatArr(outputRow, 1) = 1
        
        ' ... (le reste du code de génération de lignes  
        '     que vous aviez déjà, inchangé) ...
        
    Next
    
    ' Écriture dans la feuille
    If outputRow > 0 Then
        wsOut.Range("A1").Resize(outputRow, totalCols).Value = outputArr
        ApplyFormattingFast wsOut, formatArr, outputRow, totalCols, nbColumns
    End If
End Sub

' === FONCTIONS UTILITAIRES ULTRA-RAPIDES ===
Private Function GetLastWordFast(ByVal txt As String) As String
    Dim pos As Long
    pos = InStrRev(txt, " ")
    If pos > 0 Then
        GetLastWordFast = Mid$(txt, pos + 1)
    Else
        GetLastWordFast = txt
    End If
End Function

' (Les autres fonctions GetAbbreviatedFast, CalculateBornesFast, QuickSortByLastWordArray et
'  ApplyFormattingFast restent inchangées par rapport à votre version initiale.)
