Sub CalculerBornes()
    '=========================================================================
    ' MACRO CALCUL DES BORNES - VERSION SIMPLIFIÉE ET ROBUSTE
    ' Évite les dictionnaires complexes pour plus de stabilité
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim currentRow As Long
    
    ' Arrays pour stocker les données
    Dim dataArray As Variant
    Dim resultArray() As Variant
    Dim resultCount As Long
    
    On Error GoTo ErrorHandler
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    Set ws = Nothing
    Dim wsTemp As Worksheet
    
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name <> "Calcul des bornes" Then
            On Error Resume Next
            If InStr(UCase(wsTemp.Cells(1, 1).Value), "TOURN") > 0 And _
               InStr(UCase(wsTemp.Cells(1, 4).Value), "NUM") > 0 And _
               InStr(UCase(wsTemp.Cells(1, 6).Value), "VOIE") > 0 Then
                Set ws = wsTemp
                On Error GoTo ErrorHandler
                Exit For
            End If
            On Error GoTo ErrorHandler
        End If
    Next wsTemp
    
    If ws Is Nothing Then
        MsgBox "Feuille source non trouvée. Vérifiez les colonnes Tournée, Numéro, Voie.", vbCritical
        GoTo CleanUp
    End If
    
    ' 2. SUPPRESSION ET CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' En-têtes
    With wsCalcul
        .Cells(1, 1) = "Commune"
        .Cells(1, 2) = "Mot directeur"
        .Cells(1, 3) = "Libelle de voie"
        .Cells(1, 4) = "Ligne 3"
        .Cells(1, 5) = "Numéro de voie (borne)"
        .Cells(1, 6) = "Libelle District"
        .Cells(1, 7) = "Tournée"
        .Cells(1, 8) = "Sécable"
        .Cells(1, 9) = "Samedi"
        
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(180, 198, 231)
    End With
    
    ' 3. LECTURE DES DONNÉES EN UNE FOIS
    '=========================================================================
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    
    If lastRow < 2 Then
        MsgBox "Aucune donnée trouvée.", vbExclamation
        GoTo CleanUp
    End If
    
    ' Lire toutes les données d'un coup
    dataArray = ws.Range("A2:I" & lastRow).Value
    
    ' Initialiser le tableau de résultats
    ReDim resultArray(1 To (lastRow - 1) * 3, 1 To 9) ' Prévoir large
    resultCount = 0
    
    ' 4. TRAITEMENT LIGNE PAR LIGNE AVEC LOGIQUE SIMPLIFIÉE
    '=========================================================================
    Dim voiesTraitees As Object
    Set voiesTraitees = CreateObject("Scripting.Dictionary")
    
    ' Premier passage : identifier les voies uniques
    For i = 1 To UBound(dataArray, 1)
        Dim tournee As String, commune As String, voie As String
        Dim motDirecteur As String, secable As String, samedi As String
        
        ' Lecture sécurisée
        tournee = SafeString(dataArray(i, 1))
        commune = SafeString(dataArray(i, 7))
        voie = SafeString(dataArray(i, 6))
        motDirecteur = SafeString(dataArray(i, 5))
        secable = SafeString(dataArray(i, 8))
        samedi = SafeString(dataArray(i, 9))
        
        If tournee <> "" And commune <> "" And voie <> "" Then
            Dim cleVoie As String
            cleVoie = commune & "§" & voie & "§" & motDirecteur
            
            If Not voiesTraitees.Exists(cleVoie) Then
                voiesTraitees(cleVoie) = i ' Marquer comme vu
            End If
        End If
    Next i
    
    ' Deuxième passage : traiter chaque voie unique
    Dim voiesKeys As Variant
    voiesKeys = voiesTraitees.Keys
    
    Dim j As Long
    For j = 0 To UBound(voiesKeys)
        cleVoie = voiesKeys(j)
        Call TraiterUneVoie(cleVoie, dataArray, resultArray, resultCount)
    Next j
    
    ' 5. ÉCRITURE DES RÉSULTATS
    '=========================================================================
    If resultCount > 0 Then
        For i = 1 To resultCount
            For j = 1 To 9
                wsCalcul.Cells(i + 1, j).Value = resultArray(i, j)
            Next j
        Next i
    End If
    
    ' Mise en forme
    With wsCalcul
        .Columns("A:I").AutoFit
        .Range("A1:I" & (resultCount + 1)).Borders.LineStyle = xlContinuous
        .Range("A1:I1").HorizontalAlignment = xlCenter
        .Range("A1").Select
    End With
    
    MsgBox "Calcul terminé ! " & resultCount & " lignes générées.", vbInformation
    GoTo CleanUp
    
ErrorHandler:
    MsgBox "Erreur ligne " & i & " : " & Err.Description & " (N°" & Err.Number & ")", vbCritical
    
CleanUp:
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub

'=========================================================================
' FONCTIONS AUXILIAIRES
'=========================================================================

Function SafeString(ByVal cellValue As Variant) As String
    On Error Resume Next
    If IsEmpty(cellValue) Or IsNull(cellValue) Then
        SafeString = ""
    Else
        SafeString = Trim(CStr(cellValue))
    End If
    On Error GoTo 0
End Function

Sub TraiterUneVoie(ByVal cleVoie As String, ByRef dataArray As Variant, ByRef resultArray As Variant, ByRef resultCount As Long)
    On Error GoTo ErreurTraitement
    
    ' Extraire les informations de la clé
    Dim parts As Variant
    parts = Split(cleVoie, "§")
    If UBound(parts) < 2 Then Exit Sub
    
    Dim commune As String, voie As String, motDirecteur As String
    commune = parts(0)
    voie = parts(1)
    motDirecteur = parts(2)
    
    ' Collections pour cette voie
    Dim lignesVoie As Collection
    Set lignesVoie = New Collection
    
    Dim tournees As Collection, secables As Collection, samedis As Collection
    Set tournees = New Collection
    Set secables = New Collection
    Set samedis = New Collection
    
    ' Collecter toutes les lignes de cette voie
    Dim i As Long
    For i = 1 To UBound(dataArray, 1)
        If SafeString(dataArray(i, 7)) = commune And _
           SafeString(dataArray(i, 6)) = voie And _
           SafeString(dataArray(i, 5)) = motDirecteur Then
            
            ' Ajouter à la collection
            lignesVoie.Add i
            
            ' Collecter les valeurs uniques
            Dim t As String, s As String, sam As String
            t = SafeString(dataArray(i, 1))
            s = SafeString(dataArray(i, 8))
            sam = SafeString(dataArray(i, 9))
            
            If t <> "" Then Call AjouterSiNouveau(tournees, t)
            If s <> "" Then Call AjouterSiNouveau(secables, s)
            If sam <> "" Then Call AjouterSiNouveau(samedis, sam)
        End If
    Next i
    
    ' Déterminer si la voie est complète
    Dim estComplete As Boolean
    estComplete = (tournees.Count = 1) And (secables.Count <= 1) And (samedis.Count <= 1)
    
    ' Récupérer les valeurs de référence
    Dim refLigne As Long
    refLigne = lignesVoie(1)
    
    Dim ligne3 As String, libelleDistrict As String
    ligne3 = SafeString(dataArray(refLigne, 3))
    libelleDistrict = SafeString(dataArray(refLigne, 2))
    
    Dim tourneeRef As String, secableRef As String, samediRef As String
    tourneeRef = IIf(tournees.Count > 0, tournees(1), "")
    secableRef = IIf(secables.Count > 0, secables(1), "")
    samediRef = IIf(samedis.Count > 0, samedis(1), "")
    
    If estComplete Then
        ' Voie complète : une ligne sans borne
        resultCount = resultCount + 1
        resultArray(resultCount, 1) = commune
        resultArray(resultCount, 2) = motDirecteur
        resultArray(resultCount, 3) = voie
        resultArray(resultCount, 4) = ligne3
        resultArray(resultCount, 5) = "" ' Pas de borne
        resultArray(resultCount, 6) = libelleDistrict
        resultArray(resultCount, 7) = tourneeRef
        resultArray(resultCount, 8) = secableRef
        resultArray(resultCount, 9) = samediRef
    Else
        ' Voie incomplète : calculer les bornes
        Call CalculerBornesVoie(lignesVoie, dataArray, commune, motDirecteur, voie, ligne3, libelleDistrict, resultArray, resultCount)
    End If
    
    Exit Sub
    
ErreurTraitement:
    ' Ignorer les erreurs sur cette voie et continuer
End Sub

Sub AjouterSiNouveau(ByRef col As Collection, ByVal valeur As String)
    On Error Resume Next
    Dim temp As String
    temp = col(valeur)
    If Err.Number <> 0 Then
        col.Add valeur, valeur
    End If
    On Error GoTo 0
End Sub

Sub CalculerBornesVoie(ByRef lignesVoie As Collection, ByRef dataArray As Variant, _
                       ByVal commune As String, ByVal motDirecteur As String, ByVal voie As String, _
                       ByVal ligne3 As String, ByVal libelleDistrict As String, _
                       ByRef resultArray As Variant, ByRef resultCount As Long)
    
    On Error GoTo ErreurBornes
    
    ' Collections pour les groupes
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    ' Grouper par Tournée|Sécable|Samedi
    Dim idx As Long
    For idx = 1 To lignesVoie.Count
        Dim ligneNum As Long
        ligneNum = lignesVoie(idx)
        
        Dim numero As Variant
        numero = dataArray(ligneNum, 4)
        
        If IsNumeric(numero) And numero > 0 Then
            Dim numInt As Long
            numInt = CLng(numero)
            
            Dim combinaison As String
            combinaison = SafeString(dataArray(ligneNum, 1)) & "|" & _
                         SafeString(dataArray(ligneNum, 8)) & "|" & _
                         SafeString(dataArray(ligneNum, 9))
            
            If Not groupes.Exists(combinaison) Then
                Dim nouveauGroupe As Object
                Set nouveauGroupe = CreateObject("Scripting.Dictionary")
                nouveauGroupe("pairs") = New Collection
                nouveauGroupe("impairs") = New Collection
                groupes(combinaison) = nouveauGroupe
            End If
            
            ' Ajouter selon la parité
            If numInt Mod 2 = 0 Then
                groupes(combinaison)("pairs").Add numInt
            Else
                groupes(combinaison)("impairs").Add numInt
            End If
        End If
    Next idx
    
    ' Générer les lignes de résultat
    Dim groupesKeys As Variant
    groupesKeys = groupes.Keys
    
    Dim g As Long
    For g = 0 To UBound(groupesKeys)
        Dim groupeKey As String
        groupeKey = groupesKeys(g)
        
        Dim partsComb As Variant
        partsComb = Split(groupeKey, "|")
        
        Dim tourneeGroupe As String, secableGroupe As String, samediGroupe As String
        tourneeGroupe = IIf(UBound(partsComb) >= 0, partsComb(0), "")
        secableGroupe = IIf(UBound(partsComb) >= 1, partsComb(1), "")
        samediGroupe = IIf(UBound(partsComb) >= 2, partsComb(2), "")
        
        ' Traiter les pairs
        Dim colPairs As Collection
        Set colPairs = groupes(groupeKey)("pairs")
        
        If colPairs.Count > 0 Then
            Dim minPair As Long, maxPair As Long
            Call TrouverMinMax(colPairs, minPair, maxPair)
            
            resultCount = resultCount + 1
            resultArray(resultCount, 1) = commune
            resultArray(resultCount, 2) = motDirecteur
            resultArray(resultCount, 3) = voie
            resultArray(resultCount, 4) = ligne3
            resultArray(resultCount, 5) = minPair & " → " & maxPair
            resultArray(resultCount, 6) = libelleDistrict
            resultArray(resultCount, 7) = tourneeGroupe
            resultArray(resultCount, 8) = secableGroupe
            resultArray(resultCount, 9) = samediGroupe
        End If
        
        ' Traiter les impairs
        Dim colImpairs As Collection
        Set colImpairs = groupes(groupeKey)("impairs")
        
        If colImpairs.Count > 0 Then
            Dim minImpair As Long, maxImpair As Long
            Call TrouverMinMax(colImpairs, minImpair, maxImpair)
            
            resultCount = resultCount + 1
            resultArray(resultCount, 1) = commune
            resultArray(resultCount, 2) = motDirecteur
            resultArray(resultCount, 3) = voie
            resultArray(resultCount, 4) = ligne3
            resultArray(resultCount, 5) = minImpair & " → " & maxImpair
            resultArray(resultCount, 6) = libelleDistrict
            resultArray(resultCount, 7) = tourneeGroupe
            resultArray(resultCount, 8) = secableGroupe
            resultArray(resultCount, 9) = samediGroupe
        End If
    Next g
    
    Exit Sub
    
ErreurBornes:
    ' Ignorer cette voie en cas d'erreur
End Sub

Sub TrouverMinMax(ByRef col As Collection, ByRef minVal As Long, ByRef maxVal As Long)
    If col.Count = 0 Then Exit Sub
    
    minVal = col(1)
    maxVal = col(1)
    
    Dim i As Long
    For i = 2 To col.Count
        If col(i) < minVal Then minVal = col(i)
        If col(i) > maxVal Then maxVal = col(i)
    Next i
End Sub
