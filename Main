Sub CalculerBornes()
    On Error GoTo ErrorHandler
    
    Dim wsSource As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim resultRow As Long
    
    ' Collections pour stocker les données groupées
    Dim dictGroups As Object
    Set dictGroups = CreateObject("Scripting.Dictionary")
    
    ' Variables pour les données de chaque ligne
    Dim tournee As String, libelleDistrict As String, ligne3 As String
    Dim numero As String, motDirecteur As String, voie As String
    Dim commune As String, secable As String, samedi As String
    Dim groupKey As String, numeroInt As Long
    
    ' 1. Identifier la feuille source (première feuille du classeur)
    Set wsSource = ThisWorkbook.Worksheets(1)
    
    ' 2. Supprimer la feuille "Calcul des bornes" si elle existe
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    ' 3. Créer la nouvelle feuille "Calcul des bornes"
    Set wsResult = ThisWorkbook.Worksheets.Add
    wsResult.Name = "Calcul des bornes"
    
    ' 4. Créer les en-têtes
    With wsResult
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Formatage des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(220, 220, 220)
    End With
    
    ' 5. Lire les données et les regrouper
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    For i = 2 To lastRow ' Commencer à la ligne 2 (après les en-têtes)
        ' Lire les données de la ligne courante
        tournee = NullToEmpty(wsSource.Cells(i, 1).Value)
        libelleDistrict = NullToEmpty(wsSource.Cells(i, 2).Value)
        ligne3 = NullToEmpty(wsSource.Cells(i, 3).Value)
        numero = NullToEmpty(wsSource.Cells(i, 4).Value)
        motDirecteur = NullToEmpty(wsSource.Cells(i, 5).Value)
        voie = NullToEmpty(wsSource.Cells(i, 6).Value)
        commune = NullToEmpty(wsSource.Cells(i, 7).Value)
        secable = NullToEmpty(wsSource.Cells(i, 8).Value)
        samedi = NullToEmpty(wsSource.Cells(i, 9).Value)
        
        ' Ignorer les lignes avec numéro vide ou non numérique
        If numero <> "" And IsNumeric(numero) Then
            numeroInt = CLng(numero)
            
            ' Clé de regroupement : Commune + Mot Directeur + Voie
            groupKey = commune & "|" & motDirecteur & "|" & voie
            
            ' Initialiser le groupe s'il n'existe pas
            If Not dictGroups.Exists(groupKey) Then
                Dim newGroup As Object
                Set newGroup = CreateObject("Scripting.Dictionary")
                newGroup("commune") = commune
                newGroup("motDirecteur") = motDirecteur
                newGroup("voie") = voie
                newGroup("ligne3") = ligne3
                newGroup("libelleDistrict") = libelleDistrict
                Set newGroup("adresses") = CreateObject("Scripting.Dictionary")
                Set dictGroups(groupKey) = newGroup
            End If
            
            ' Ajouter l'adresse au groupe
            Dim adresseKey As String
            adresseKey = tournee & "|" & secable & "|" & samedi & "|" & CStr(numeroInt)
            
            If Not dictGroups(groupKey)("adresses").Exists(adresseKey) Then
                Dim newAdresse As Object
                Set newAdresse = CreateObject("Scripting.Dictionary")
                newAdresse("tournee") = tournee
                newAdresse("secable") = secable
                newAdresse("samedi") = samedi
                newAdresse("numero") = numeroInt
                Set dictGroups(groupKey)("adresses")(adresseKey) = newAdresse
            End If
        End If
    Next i
    
    ' 6. Traiter chaque groupe
    resultRow = 2
    Dim groupKeys As Variant
    groupKeys = dictGroups.Keys
    
    Dim j As Long
    For j = 0 To UBound(groupKeys)
        Dim currentGroup As Object
        Set currentGroup = dictGroups(groupKeys(j))
        
        ' Vérifier si la voie est complète
        If EstVoieComplete(currentGroup("adresses")) Then
            ' Voie complète : une seule ligne sans borne
            Dim adresseKeys As Variant
            adresseKeys = currentGroup("adresses").Keys
            Dim premierAdresse As Object
            Set premierAdresse = currentGroup("adresses")(adresseKeys(0))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), "", _
                currentGroup("libelleDistrict"), premierAdresse("tournee"), _
                premierAdresse("secable"), premierAdresse("samedi")
            resultRow = resultRow + 1
        Else
            ' Voie non complète : calculer les bornes
            CalculerEtEcrireBornes currentGroup, wsResult, resultRow
        End If
    Next j
    
    ' 7. Ajuster la largeur des colonnes
    wsResult.Columns("A:I").AutoFit
    
    MsgBox "Calcul des bornes terminé. " & (resultRow - 2) & " lignes générées.", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur ligne " & i & " : " & Err.Description, vbCritical
End Sub

' Fonction utilitaire pour gérer les valeurs null
Private Function NullToEmpty(value As Variant) As String
    If IsNull(value) Or IsEmpty(value) Then
        NullToEmpty = ""
    Else
        NullToEmpty = Trim(CStr(value))
    End If
End Function

' Fonction pour vérifier si une voie est complète
Private Function EstVoieComplete(adresses As Object) As Boolean
    Dim keys As Variant
    keys = adresses.Keys
    
    If UBound(keys) < 0 Then
        EstVoieComplete = True
        Exit Function
    End If
    
    ' Obtenir les valeurs de référence (première adresse)
    Dim refTournee As String, refSecable As String, refSamedi As String
    Dim premierAdresse As Object
    Set premierAdresse = adresses(keys(0))
    refTournee = premierAdresse("tournee")
    refSecable = premierAdresse("secable")
    refSamedi = premierAdresse("samedi")
    
    ' Vérifier que toutes les adresses ont les mêmes valeurs
    Dim j As Long
    For j = 0 To UBound(keys)
        Dim currentAdresse As Object
        Set currentAdresse = adresses(keys(j))
        
        If currentAdresse("tournee") <> refTournee Or _
           currentAdresse("secable") <> refSecable Or _
           currentAdresse("samedi") <> refSamedi Then
            EstVoieComplete = False
            Exit Function
        End If
    Next j
    
    EstVoieComplete = True
End Function

' Subroutine pour calculer et écrire les bornes
Private Sub CalculerEtEcrireBornes(currentGroup As Object, wsResult As Worksheet, ByRef resultRow As Long)
    ' Regrouper par Tournée + Sécable + Samedi
    Dim dictSubGroups As Object
    Set dictSubGroups = CreateObject("Scripting.Dictionary")
    
    Dim adresseKeys As Variant
    adresseKeys = currentGroup("adresses").Keys
    
    Dim j As Long
    For j = 0 To UBound(adresseKeys)
        Dim currentAdresse As Object
        Set currentAdresse = currentGroup("adresses")(adresseKeys(j))
        
        Dim subGroupKey As String
        subGroupKey = currentAdresse("tournee") & "|" & currentAdresse("secable") & "|" & currentAdresse("samedi")
        
        If Not dictSubGroups.Exists(subGroupKey) Then
            Dim newSubGroup As Object
            Set newSubGroup = CreateObject("Scripting.Dictionary")
            newSubGroup("tournee") = currentAdresse("tournee")
            newSubGroup("secable") = currentAdresse("secable")
            newSubGroup("samedi") = currentAdresse("samedi")
            newSubGroup("pairs") = ""
            newSubGroup("impairs") = ""
            Set dictSubGroups(subGroupKey) = newSubGroup
        End If
        
        ' Séparer pairs et impairs (utiliser des chaînes de caractères)
        If currentAdresse("numero") Mod 2 = 0 Then
            If dictSubGroups(subGroupKey)("pairs") = "" Then
                dictSubGroups(subGroupKey)("pairs") = CStr(currentAdresse("numero"))
            Else
                dictSubGroups(subGroupKey)("pairs") = dictSubGroups(subGroupKey)("pairs") & "," & CStr(currentAdresse("numero"))
            End If
        Else
            If dictSubGroups(subGroupKey)("impairs") = "" Then
                dictSubGroups(subGroupKey)("impairs") = CStr(currentAdresse("numero"))
            Else
                dictSubGroups(subGroupKey)("impairs") = dictSubGroups(subGroupKey)("impairs") & "," & CStr(currentAdresse("numero"))
            End If
        End If
    Next j
    
    ' Écrire les bornes pour chaque sous-groupe
    Dim subGroupKeys As Variant
    subGroupKeys = dictSubGroups.Keys
    
    For j = 0 To UBound(subGroupKeys)
        Dim currentSubGroup As Object
        Set currentSubGroup = dictSubGroups(subGroupKeys(j))
        
        ' Traiter les pairs
        If currentSubGroup("pairs") <> "" Then
            Dim bornePairs As String
            bornePairs = CalculerBorneDepuisChaine(currentSubGroup("pairs"))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), bornePairs, _
                currentGroup("libelleDistrict"), currentSubGroup("tournee"), _
                currentSubGroup("secable"), currentSubGroup("samedi")
            resultRow = resultRow + 1
        End If
        
        ' Traiter les impairs
        If currentSubGroup("impairs") <> "" Then
            Dim borneImpairs As String
            borneImpairs = CalculerBorneDepuisChaine(currentSubGroup("impairs"))
            
            EcrireLigneResultat wsResult, resultRow, _
                currentGroup("commune"), currentGroup("motDirecteur"), _
                currentGroup("voie"), currentGroup("ligne3"), borneImpairs, _
                currentGroup("libelleDistrict"), currentSubGroup("tournee"), _
                currentSubGroup("secable"), currentSubGroup("samedi")
            resultRow = resultRow + 1
        End If
    Next j
End Sub

' Fonction pour calculer une borne à partir d'une chaîne de numéros séparés par des virgules
Private Function CalculerBorneDepuisChaine(numerosStr As String) As String
    If numerosStr = "" Then
        CalculerBorneDepuisChaine = ""
        Exit Function
    End If
    
    ' Séparer la chaîne et convertir en tableau
    Dim numerosArray As Variant
    numerosArray = Split(numerosStr, ",")
    
    Dim i As Long, j As Long
    Dim temp As Long
    
    ' Convertir en tableau de Long et trier
    Dim numArray() As Long
    ReDim numArray(0 To UBound(numerosArray))
    
    For i = 0 To UBound(numerosArray)
        numArray(i) = CLng(numerosArray(i))
    Next i
    
    ' Tri simple (bulle sort)
    For i = 0 To UBound(numArray) - 1
        For j = i + 1 To UBound(numArray)
            If numArray(i) > numArray(j) Then
                temp = numArray(i)
                numArray(i) = numArray(j)
                numArray(j) = temp
            End If
        Next j
    Next i
    
    ' Retourner la borne formatée
    If UBound(numArray) = 0 Then
        CalculerBorneDepuisChaine = CStr(numArray(0))
    Else
        CalculerBorneDepuisChaine = CStr(numArray(0)) & " → " & CStr(numArray(UBound(numArray)))
    End If
End Function

' Subroutine pour écrire une ligne de résultat
Private Sub EcrireLigneResultat(ws As Worksheet, row As Long, _
    commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, borne As String, libelleDistrict As String, _
    tournee As String, secable As String, samedi As String)
    
    With ws
        .Cells(row, 1).Value = commune
        .Cells(row, 2).Value = motDirecteur
        .Cells(row, 3).Value = voie
        .Cells(row, 4).Value = ligne3
        .Cells(row, 5).Value = borne
        .Cells(row, 6).Value = libelleDistrict
        .Cells(row, 7).Value = tournee
        .Cells(row, 8).Value = secable
        .Cells(row, 9).Value = samedi
    End With
End Sub
