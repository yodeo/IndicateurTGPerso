Sub CalculerBornes()
    '=========================================================================
    ' MACRO CALCUL DES BORNES - VERSION AVEC DEBUG
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim currentRow As Long
    
    ' Arrays pour stocker les données
    Dim dataArray As Variant
    Dim resultArray() As Variant
    Dim resultCount As Long
    
    On Error GoTo ErrorHandler
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    
    Set ws = Nothing
    Dim wsTemp As Worksheet
    Dim debugMsg As String
    
    ' Debug : lister toutes les feuilles
    debugMsg = "Feuilles disponibles :" & vbCrLf
    For Each wsTemp In ThisWorkbook.Worksheets
        debugMsg = debugMsg & "- " & wsTemp.Name & vbCrLf
        If wsTemp.Name <> "Calcul des bornes" Then
            ' Vérifier les en-têtes de cette feuille
            Dim header1 As String, header4 As String, header6 As String
            On Error Resume Next
            header1 = Trim(UCase(CStr(wsTemp.Cells(1, 1).Value)))
            header4 = Trim(UCase(CStr(wsTemp.Cells(1, 4).Value)))
            header6 = Trim(UCase(CStr(wsTemp.Cells(1, 6).Value)))
            On Error GoTo ErrorHandler
            
            debugMsg = debugMsg & "  En-têtes: " & header1 & " | " & header4 & " | " & header6 & vbCrLf
            
            ' Critères de détection plus flexibles
            If (InStr(header1, "TOURN") > 0 Or header1 = "TOURNÉE") And _
               (InStr(header4, "NUM") > 0 Or header4 = "NUMÉRO") And _
               (InStr(header6, "VOIE") > 0) Then
                Set ws = wsTemp
                debugMsg = debugMsg & "  *** FEUILLE SÉLECTIONNÉE ***" & vbCrLf
                Exit For
            End If
        End If
    Next wsTemp
    
    If ws Is Nothing Then
        MsgBox debugMsg & vbCrLf & "Aucune feuille source trouvée !", vbCritical
        GoTo CleanUp
    End If
    
    ' 2. SUPPRESSION ET CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' En-têtes
    With wsCalcul
        .Cells(1, 1) = "Commune"
        .Cells(1, 2) = "Mot directeur"
        .Cells(1, 3) = "Libelle de voie"
        .Cells(1, 4) = "Ligne 3"
        .Cells(1, 5) = "Numéro de voie (borne)"
        .Cells(1, 6) = "Libelle District"
        .Cells(1, 7) = "Tournée"
        .Cells(1, 8) = "Sécable"
        .Cells(1, 9) = "Samedi"
        
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(180, 198, 231)
    End With
    
    ' 3. LECTURE DES DONNÉES
    '=========================================================================
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row
    debugMsg = debugMsg & vbCrLf & "Feuille: " & ws.Name & vbCrLf & "Dernière ligne: " & lastRow
    
    If lastRow < 2 Then
        MsgBox debugMsg & vbCrLf & "Aucune donnée trouvée (lastRow < 2).", vbExclamation
        GoTo CleanUp
    End If
    
    ' Lire toutes les données d'un coup
    dataArray = ws.Range("A2:I" & lastRow).Value
    debugMsg = debugMsg & vbCrLf & "Données lues: " & UBound(dataArray, 1) & " lignes"
    
    ' Debug : afficher quelques premières lignes
    debugMsg = debugMsg & vbCrLf & "Échantillon de données:"
    For i = 1 To WorksheetFunction.Min(3, UBound(dataArray, 1))
        debugMsg = debugMsg & vbCrLf & "Ligne " & i & ": " & _
                   SafeString(dataArray(i, 1)) & " | " & _
                   SafeString(dataArray(i, 6)) & " | " & _
                   SafeString(dataArray(i, 7))
    Next i
    
    ' Initialiser le tableau de résultats
    ReDim resultArray(1 To (lastRow - 1) * 3, 1 To 9)
    resultCount = 0
    
    ' 4. TRAITEMENT SIMPLIFIÉ LIGNE PAR LIGNE
    '=========================================================================
    Dim voiesTraitees As Object
    Set voiesTraitees = CreateObject("Scripting.Dictionary")
    
    ' Compter les lignes valides
    Dim lignesValides As Long
    lignesValides = 0
    
    ' Premier passage : identifier les voies uniques
    For i = 1 To UBound(dataArray, 1)
        Dim tournee As String, commune As String, voie As String
        Dim motDirecteur As String
        
        ' Lecture sécurisée
        tournee = SafeString(dataArray(i, 1))
        commune = SafeString(dataArray(i, 7))
        voie = SafeString(dataArray(i, 6))
        motDirecteur = SafeString(dataArray(i, 5))
        
        If tournee <> "" And commune <> "" And voie <> "" Then
            lignesValides = lignesValides + 1
            Dim cleVoie As String
            cleVoie = commune & "§" & voie & "§" & motDirecteur
            
            If Not voiesTraitees.Exists(cleVoie) Then
                voiesTraitees(cleVoie) = i
            End If
        End If
    Next i
    
    debugMsg = debugMsg & vbCrLf & "Lignes valides: " & lignesValides
    debugMsg = debugMsg & vbCrLf & "Voies uniques: " & voiesTraitees.Count
    
    If voiesTraitees.Count = 0 Then
        MsgBox debugMsg & vbCrLf & vbCrLf & "Aucune voie valide trouvée ! Vérifiez les colonnes Tournée, Commune, Voie.", vbExclamation
        GoTo CleanUp
    End If
    
    ' Deuxième passage : traiter chaque voie unique
    Dim voiesKeys As Variant
    voiesKeys = voiesTraitees.Keys
    
    Dim j As Long
    For j = 0 To UBound(voiesKeys)
        cleVoie = voiesKeys(j)
        Call TraiterUneVoieSimple(cleVoie, dataArray, resultArray, resultCount)
    Next j
    
    debugMsg = debugMsg & vbCrLf & "Lignes de résultat générées: " & resultCount
    
    ' 5. ÉCRITURE DES RÉSULTATS
    '=========================================================================
    If resultCount > 0 Then
        For i = 1 To resultCount
            For j = 1 To 9
                wsCalcul.Cells(i + 1, j).Value = resultArray(i, j)
            Next j
        Next i
    End If
    
    ' Mise en forme
    With wsCalcul
        .Columns("A:I").AutoFit
        If resultCount > 0 Then
            .Range("A1:I" & (resultCount + 1)).Borders.LineStyle = xlContinuous
        End If
        .Range("A1:I1").HorizontalAlignment = xlCenter
        .Range("A1").Select
    End With
    
    ' Message final avec debug
    MsgBox debugMsg & vbCrLf & vbCrLf & "RÉSULTAT: " & resultCount & " lignes générées.", vbInformation
    GoTo CleanUp
    
ErrorHandler:
    MsgBox "Erreur ligne " & i & " : " & Err.Description & " (N°" & Err.Number & ")" & vbCrLf & vbCrLf & debugMsg, vbCritical
    
CleanUp:
    Application.ScreenUpdating = True
    Application.DisplayAlerts = True
End Sub

'=========================================================================
' FONCTIONS AUXILIAIRES SIMPLIFIÉES
'=========================================================================

Function SafeString(ByVal cellValue As Variant) As String
    On Error Resume Next
    If IsEmpty(cellValue) Or IsNull(cellValue) Or VarType(cellValue) = vbError Then
        SafeString = ""
    Else
        SafeString = Trim(CStr(cellValue))
        If SafeString = "0" Then SafeString = ""
    End If
    On Error GoTo 0
End Function

Sub TraiterUneVoieSimple(ByVal cleVoie As String, ByRef dataArray As Variant, ByRef resultArray As Variant, ByRef resultCount As Long)
    On Error GoTo ErreurTraitement
    
    ' Extraire les informations de la clé
    Dim parts As Variant
    parts = Split(cleVoie, "§")
    If UBound(parts) < 2 Then Exit Sub
    
    Dim commune As String, voie As String, motDirecteur As String
    commune = parts(0)
    voie = parts(1)
    motDirecteur = parts(2)
    
    ' Variables pour analyser la voie
    Dim tournees As New Collection
    Dim secables As New Collection
    Dim samedis As New Collection
    Dim numeros As New Collection
    
    ' Variables de référence pour la première ligne trouvée
    Dim ligne3 As String, libelleDistrict As String
    Dim tourneeRef As String, secableRef As String, samediRef As String
    Dim premiereIteration As Boolean
    premiereIteration = True
    
    ' Collecter toutes les informations de cette voie
    Dim i As Long
    For i = 1 To UBound(dataArray, 1)
        If SafeString(dataArray(i, 7)) = commune And _
           SafeString(dataArray(i, 6)) = voie And _
           SafeString(dataArray(i, 5)) = motDirecteur Then
            
            ' Première ligne : récupérer les valeurs de référence
            If premiereIteration Then
                ligne3 = SafeString(dataArray(i, 3))
                libelleDistrict = SafeString(dataArray(i, 2))
                premiereIteration = False
            End If
            
            ' Collecter les valeurs pour déterminer si la voie est complète
            Dim t As String, s As String, sam As String
            t = SafeString(dataArray(i, 1))
            s = SafeString(dataArray(i, 8))
            sam = SafeString(dataArray(i, 9))
            
            If t <> "" Then
                Call AjouterSiNouveau(tournees, t)
                tourneeRef = t ' Garder la dernière valeur comme référence
            End If
            If s <> "" Then
                Call AjouterSiNouveau(secables, s)
                secableRef = s
            End If
            If sam <> "" Then
                Call AjouterSiNouveau(samedis, sam)
                samediRef = sam
            End If
            
            ' Collecter les numéros valides
            Dim numero As Variant
            numero = dataArray(i, 4)
            If IsNumeric(numero) And numero <> "" And numero > 0 Then
                numeros.Add CLng(numero)
            End If
        End If
    Next i
    
    ' Déterminer si la voie est complète
    Dim estComplete As Boolean
    estComplete = (tournees.Count = 1) And (secables.Count <= 1) And (samedis.Count <= 1)
    
    If estComplete Then
        ' Voie complète : une ligne sans borne
        resultCount = resultCount + 1
        resultArray(resultCount, 1) = commune
        resultArray(resultCount, 2) = motDirecteur
        resultArray(resultCount, 3) = voie
        resultArray(resultCount, 4) = ligne3
        resultArray(resultCount, 5) = "" ' Pas de borne
        resultArray(resultCount, 6) = libelleDistrict
        resultArray(resultCount, 7) = tourneeRef
        resultArray(resultCount, 8) = secableRef
        resultArray(resultCount, 9) = samediRef
    Else
        ' Voie incomplète : séparer pairs et impairs
        If numeros.Count > 0 Then
            Dim pairs As New Collection
            Dim impairs As New Collection
            
            For i = 1 To numeros.Count
                If numeros(i) Mod 2 = 0 Then
                    pairs.Add numeros(i)
                Else
                    impairs.Add numeros(i)
                End If
            Next i
            
            ' Générer ligne pour les pairs
            If pairs.Count > 0 Then
                Dim minPair As Long, maxPair As Long
                Call TrouverMinMax(pairs, minPair, maxPair)
                
                resultCount = resultCount + 1
                resultArray(resultCount, 1) = commune
                resultArray(resultCount, 2) = motDirecteur
                resultArray(resultCount, 3) = voie
                resultArray(resultCount, 4) = ligne3
                resultArray(resultCount, 5) = minPair & " → " & maxPair
                resultArray(resultCount, 6) = libelleDistrict
                resultArray(resultCount, 7) = tourneeRef
                resultArray(resultCount, 8) = secableRef
                resultArray(resultCount, 9) = samediRef
            End If
            
            ' Générer ligne pour les impairs
            If impairs.Count > 0 Then
                Dim minImpair As Long, maxImpair As Long
                Call TrouverMinMax(impairs, minImpair, maxImpair)
                
                resultCount = resultCount + 1
                resultArray(resultCount, 1) = commune
                resultArray(resultCount, 2) = motDirecteur
                resultArray(resultCount, 3) = voie
                resultArray(resultCount, 4) = ligne3
                resultArray(resultCount, 5) = minImpair & " → " & maxImpair
                resultArray(resultCount, 6) = libelleDistrict
                resultArray(resultCount, 7) = tourneeRef
                resultArray(resultCount, 8) = secableRef
                resultArray(resultCount, 9) = samediRef
            End If
        End If
    End If
    
    Exit Sub
    
ErreurTraitement:
    ' Ignorer les erreurs sur cette voie et continuer
End Sub

Sub AjouterSiNouveau(ByRef col As Collection, ByVal valeur As String)
    On Error Resume Next
    Dim temp As String
    temp = col(valeur)
    If Err.Number <> 0 Then
        col.Add valeur, valeur
    End If
    On Error GoTo 0
End Sub

Sub TrouverMinMax(ByRef col As Collection, ByRef minVal As Long, ByRef maxVal As Long)
    If col.Count = 0 Then Exit Sub
    
    minVal = col(1)
    maxVal = col(1)
    
    Dim i As Long
    For i = 2 To col.Count
        If col(i) < minVal Then minVal = col(i)
        If col(i) > maxVal Then maxVal = col(i)
    Next i
End Sub
