Option Explicit

' --- Globals ---
Public g_wsSrc      As Worksheet
Public g_dataArr    As Variant
Public g_colComm    As Long
Public g_colVoie    As Long
Public g_colNum     As Long
Public g_colTour    As Long
Public g_colSecable As Long
Public g_colLigne   As Long
Public g_colLigne3  As Long

' === STRUCTURES DE DONNÉES OPTIMISÉES ===
Private Type TourneeInfo
    commune As String
    voie As String
    tournee As String
    nums() As Long
    numCount As Long
    ligneText As String
    ligne3Text As String
    isMultiTournee As Boolean
End Type

' === API Windows pour mesurer le temps ===
#If VBA7 Then
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
#Else
    Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If

' === FONCTION PRINCIPALE ULTRA-OPTIMISÉE ===
Public Sub GenererIndicateurTournées()
    Dim startTime As Long
    startTime = GetTickCount
    
    Dim nbColumns As Long, mode As Long
    Dim wsOut As Worksheet
    Dim useToutSauf As Boolean
    
    ' Interface utilisateur
    nbColumns = Application.InputBox( _
        "Nombre de colonnes pour l'affichage ?" & vbCrLf & _
        "(1 = mode simple, 2+ = mode multi-colonnes)", _
        "Configuration de l'affichage", 1, Type:=1)
    
    If nbColumns < 1 Then
        MsgBox "Le nombre de colonnes doit être au moins 1.", vbExclamation
        Exit Sub
    End If

    mode = Application.InputBox( _
        "Mode d'affichage :" & vbCrLf & _
        "1 = Standard (toutes les voies)" & vbCrLf & _
        "2 = Tout sauf (masquer les voies majoritaires)", _
        "Mode d'affichage", 1, Type:=1)
    
    If mode <> 1 And mode <> 2 Then
        MsgBox "Mode invalide.", vbExclamation
        Exit Sub
    End If
    
    useToutSauf = (mode = 2)
    
    ' Optimisations Excel
    With Application
        .ScreenUpdating = False
        .Calculation = xlCalculationManual
        .EnableEvents = False
        .DisplayStatusBar = False
        .PrintCommunication = False
    End With
    
    ' Créer la feuille de sortie
    On Error Resume Next
    Application.DisplayAlerts = False
    Worksheets("indicateur de tg à vérifier").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Set wsOut = Worksheets.Add(After:=Sheets(Sheets.Count))
    wsOut.Name = "indicateur de tg à vérifier"
    
    ' Traitement principal
    ProcessDataUltraFast ActiveSheet, wsOut, nbColumns, useToutSauf
    
    ' Restaurer Excel
    With Application
        .ScreenUpdating = True
        .Calculation = xlCalculationAutomatic
        .EnableEvents = True
        .DisplayStatusBar = True
        .PrintCommunication = True
    End With
    
    Dim elapsedTime As Long
    elapsedTime = GetTickCount - startTime
    
    MsgBox "Indicateur généré avec " & nbColumns & " colonne(s) dans 'indicateur de tg à vérifier'." & _
           vbCrLf & "Temps d'exécution : " & Format(elapsedTime / 1000, "0.00") & " secondes", vbInformation
End Sub

' === TRAITEMENT PRINCIPAL ULTRA-RAPIDE ===
Private Sub ProcessDataUltraFast(wsSource As Worksheet, wsOut As Worksheet, _
                                nbColumns As Long, useToutSauf As Boolean)
    
    Dim dataArr As Variant
    Dim outputArr() As Variant
    Dim formatArr() As Variant
    Dim rowCount As Long, colCount As Long
    Dim i As Long, j As Long, outputRow As Long
    Dim totalCols As Long
    
    ' Charger toutes les données en mémoire
    dataArr = wsSource.UsedRange.Value
    rowCount = UBound(dataArr, 1)
    colCount = UBound(dataArr, 2)
    
    ' Identifier les colonnes
    Dim colMap(1 To 7) As Long
    For j = 1 To colCount
        Select Case UCase$(Trim(dataArr(1, j)))
            Case "COMMUNE":   colMap(1) = j
            Case "VOIE":      colMap(2) = j
            Case "NUMÉRO", "NUMERO": colMap(3) = j
            Case "TOURNÉE", "TOURNEE": colMap(4) = j
            Case "SÉCABLE", "SECABLE": colMap(5) = j
            Case "LIGNE":     colMap(6) = j
            Case "LIGNE 3":   colMap(7) = j
        End Select
    Next j
    
    If colMap(1) * colMap(2) * colMap(3) * colMap(4) = 0 Then
        MsgBox "Colonnes obligatoires introuvables", vbCritical
        Exit Sub
    End If
    
    ' Prétraitement : création d'une structure de données optimisée
    Dim dataDict As Object
    Set dataDict = CreateObject("Scripting.Dictionary")
    
    ' Parcours unique des données avec construction immédiate
    Dim commune As String, voie As String, tournee As String, numero As String
    Dim secable As String, ligne As String, ligne3 As String
    Dim key As Variant, subKey As String
    Dim keyStr As String
    
    For i = 2 To rowCount
        commune = Trim(CStr(dataArr(i, colMap(1))))
        voie = Trim(CStr(dataArr(i, colMap(2))))
        numero = Trim(CStr(dataArr(i, colMap(3))))
        tournee = Trim(CStr(dataArr(i, colMap(4))))
        
        If colMap(5) > 0 Then
            secable = Trim(CStr(dataArr(i, colMap(5))))
            If Len(secable) > 0 Then tournee = tournee & " (" & secable & ")"
        End If
        
        key = commune & "|" & voie & "|" & tournee
        
        If Not dataDict.Exists(key) Then
            dataDict.Add key, CreateObject("Scripting.Dictionary")
            dataDict(key)("nums") = CreateObject("Scripting.Dictionary")
            dataDict(key)("ligne") = ""
            dataDict(key)("ligne3") = CreateObject("Scripting.Dictionary")
        End If
        
        ' Ajouter le numéro
        If IsNumeric(numero) Then
            dataDict(key)("nums")(CLng(numero)) = True
        End If
        
        ' Ligne
        If colMap(6) > 0 Then
            ligne = Trim(CStr(dataArr(i, colMap(6))))
            If Len(ligne) > 0 And dataDict(key)("ligne") = "" Then
                dataDict(key)("ligne") = ligne
            End If
        End If
        
        ' Ligne 3
        If colMap(7) > 0 Then
            ligne3 = Trim(CStr(dataArr(i, colMap(7))))
            If Len(ligne3) > 0 Then
                dataDict(key)("ligne3")(ligne3) = True
            End If
        End If
    Next i
    
    ' Générer la sortie
    totalCols = nbColumns * 2
    ReDim outputArr(1 To rowCount, 1 To totalCols)
    ReDim formatArr(1 To rowCount, 1 To 5) ' Pour stocker les infos de formatage
    
    outputRow = 0
    
    ' Traitement par commune
    Dim communes As Object, voies As Object
    Set communes = CreateObject("Scripting.Dictionary")
    
    ' Regrouper par commune
    For Each key In dataDict.Keys
        Dim parts() As String
        parts = Split(CStr(key), "|")
        commune = parts(0)
        
        If Not communes.Exists(commune) Then
            Set communes(commune) = CreateObject("Scripting.Dictionary")
        End If
        communes(commune)(CStr(key)) = True
    Next
    
    ' Générer la sortie optimisée
    Dim communeKeys As Variant, voieKeys As Variant
    Dim lastWord As String, prevLetter As String
    Dim bornes As String, fullText As String
    Dim communeVar As Variant, voieVar As Variant, tourneeVar As Variant
    
    communeKeys = communes.Keys
    communeKeys = QuickSortByLastWordArray(communeKeys)
    
    For Each communeVar In communeKeys
        commune = CStr(communeVar)
        outputRow = outputRow + 1
        
        ' En-tête de commune
        outputArr(outputRow, 1) = commune
        formatArr(outputRow, 1) = 1 ' Type en-tête commune
        
        ' Traiter les voies
        Dim communeData As Object
        Set communeData = CreateObject("Scripting.Dictionary")
        
        For Each key In communes(commune).Keys
            parts = Split(CStr(key), "|")
            voie = parts(1)
            tournee = parts(2)
            
            If Not communeData.Exists(voie) Then
                Set communeData(voie) = CreateObject("Scripting.Dictionary")
            End If
            communeData(voie)(tournee) = CStr(key)
        Next
        
        ' Déterminer le mode tout sauf
        Dim tourneeCount As Object
        Set tourneeCount = CreateObject("Scripting.Dictionary")
        Dim allTournees As Object
        Set allTournees = CreateObject("Scripting.Dictionary")
        
        For Each voieVar In communeData.Keys
            voie = CStr(voieVar)
            For Each tourneeVar In communeData(voie).Keys
                tournee = CStr(tourneeVar)
                allTournees(tournee) = True
                If communeData(voie).Count = 1 Then
                    If Not tourneeCount.Exists(tournee) Then tourneeCount(tournee) = 0
                    tourneeCount(tournee) = tourneeCount(tournee) + 1
                End If
            Next
        Next
        
        ' Modifier l'en-tête si nécessaire
        If allTournees.Count = 1 Then
            outputArr(outputRow, 1) = commune & " (" & allTournees.Keys()(0) & ")"
            formatArr(outputRow, 1) = 2 ' Jaune
        ElseIf useToutSauf And allTournees.Count <= 4 Then
            Dim majorityTour As String, maxCount As Long
            maxCount = 0
            For Each tourneeVar In tourneeCount.Keys
                tournee = CStr(tourneeVar)
                If tourneeCount(tournee) > maxCount Then
                    maxCount = tourneeCount(tournee)
                    majorityTour = tournee
                End If
            Next
            If maxCount > 0 Then
                outputArr(outputRow, 1) = commune & " (" & majorityTour & ") sauf :"
                formatArr(outputRow, 1) = 3 ' Bleu
            End If
        End If
        
        ' Traiter les voies
        voieKeys = communeData.Keys
        voieKeys = QuickSortByLastWordArray(voieKeys)
        
        Dim ligneBuffer() As Variant
        ReDim ligneBuffer(1 To 1000, 1 To 5)
        Dim bufferCount As Long
        bufferCount = 0
        
        prevLetter = ""
        For Each voieVar In voieKeys
            voie = CStr(voieVar)
            For Each tourneeVar In communeData(voie).Keys
                tournee = CStr(tourneeVar)
                keyStr = communeData(voie)(tournee)
                
                ' Construire le texte
                lastWord = GetLastWordFast(voie)
                fullText = UCase$(lastWord) & " (" & GetAbbreviatedFast(voie) & ")"
                
                ' Ajouter ligne3
                If dataDict(keyStr)("ligne3").Count > 0 Then
                    fullText = fullText & " " & Join(dataDict(keyStr)("ligne3").Keys, " - ") & " -"
                End If
                
                ' Ajouter ligne
                If dataDict(keyStr)("ligne") <> "" Then
                    fullText = fullText & " " & dataDict(keyStr)("ligne")
                End If
                
                ' Calculer les bornes si multi-tournées
                If communeData(voie).Count > 1 Then
                    Dim numsDictTemp As Object
                    Set numsDictTemp = dataDict(keyStr)("nums")
                    bornes = CalculateBornesFast(numsDictTemp)
                    If bornes <> "" Then fullText = fullText & " " & bornes
                End If
                
                bufferCount = bufferCount + 1
                ligneBuffer(bufferCount, 1) = fullText
                ligneBuffer(bufferCount, 2) = tournee
                ligneBuffer(bufferCount, 3) = IIf(communeData(voie).Count > 1, 1, 0)
                ligneBuffer(bufferCount, 4) = IIf(Left(UCase$(lastWord), 1) <> prevLetter, 1, 0)
                ligneBuffer(bufferCount, 5) = Len(lastWord)
                
                prevLetter = Left(UCase$(lastWord), 1)
            Next
        Next
        
        ' Écrire les lignes dans le tableau de sortie
        If nbColumns = 1 Then
            For i = 1 To bufferCount
                outputRow = outputRow + 1
                outputArr(outputRow, 1) = ligneBuffer(i, 1)
                outputArr(outputRow, 2) = ligneBuffer(i, 2)
                formatArr(outputRow, 1) = 10 + ligneBuffer(i, 3) ' 10=normal, 11=vert
                formatArr(outputRow, 2) = ligneBuffer(i, 4) ' Nouvelle lettre
                formatArr(outputRow, 3) = ligneBuffer(i, 5) ' Longueur dernier mot
            Next
        Else
            For i = 1 To bufferCount Step nbColumns
                outputRow = outputRow + 1
                For j = 0 To nbColumns - 1
                    If i + j <= bufferCount Then
                        outputArr(outputRow, 1 + 2 * j) = ligneBuffer(i + j, 1)
                        outputArr(outputRow, 1 + 2 * j + 1) = ligneBuffer(i + j, 2)
                        formatArr(outputRow, 1 + j) = 10 + ligneBuffer(i + j, 3)
                    End If
                Next
            Next
        End If
    Next
    
    ' Écrire tout en une fois
    If outputRow > 0 Then
        wsOut.Range("A1").Resize(outputRow, totalCols).Value = outputArr
        
        ' Appliquer le formatage minimal nécessaire
        ApplyFormattingFast wsOut, formatArr, outputRow, totalCols, nbColumns
    End If
End Sub

' === FONCTIONS UTILITAIRES ULTRA-RAPIDES ===
Private Function GetLastWordFast(ByVal txt As String) As String
    Dim pos As Long
    pos = InStrRev(txt, " ")
    If pos > 0 Then
        GetLastWordFast = Mid$(txt, pos + 1)
    Else
        GetLastWordFast = txt
    End If
End Function

Private Function GetAbbreviatedFast(ByVal voie As String) As String
    Static abbrDict As Object
    If abbrDict Is Nothing Then
        Set abbrDict = CreateObject("Scripting.Dictionary")
        abbrDict("IMPASSE") = "IMP."
        abbrDict("ROUTE") = "RTE."
        abbrDict("AVENUE") = "AV."
        abbrDict("BOULEVARD") = "BD."
        abbrDict("CHEMIN") = "CH."
        abbrDict("ALLEE") = "ALL."
        abbrDict("PLACE") = "PL."
        abbrDict("SQUARE") = "SQ."
    End If
    
    Dim pos As Long, firstWord As String
    pos = InStr(voie, " ")
    If pos > 0 Then
        firstWord = UCase$(Left$(voie, pos - 1))
        If abbrDict.Exists(firstWord) Then
            GetAbbreviatedFast = abbrDict(firstWord) & Mid$(voie, pos, InStrRev(voie, " ") - pos)
        Else
            GetAbbreviatedFast = Left$(voie, InStrRev(voie, " ") - 1)
        End If
    Else
        GetAbbreviatedFast = voie
    End If
End Function

Private Function CalculateBornesFast(ByVal numsDict As Variant) As String
    If Not IsObject(numsDict) Then
        CalculateBornesFast = ""
        Exit Function
    End If
    
    If numsDict.Count = 0 Then
        CalculateBornesFast = ""
        Exit Function
    End If
    
    Dim nums() As Long, i As Long
    ReDim nums(0 To numsDict.Count - 1)
    
    i = 0
    Dim num As Variant
    For Each num In numsDict.Keys
        nums(i) = CLng(num)
        i = i + 1
    Next
    
    ' Tri rapide inline
    Dim j As Long, temp As Long
    For i = 0 To UBound(nums) - 1
        For j = i + 1 To UBound(nums)
            If nums(i) > nums(j) Then
                temp = nums(i)
                nums(i) = nums(j)
                nums(j) = temp
            End If
        Next
    Next
    
    ' Calcul des bornes
    Dim oddMin As Long, oddMax As Long, evenMin As Long, evenMax As Long
    oddMin = 999999: oddMax = -1: evenMin = 999999: evenMax = -1
    
    For i = 0 To UBound(nums)
        If nums(i) Mod 2 = 0 Then
            If nums(i) < evenMin Then evenMin = nums(i)
            If nums(i) > evenMax Then evenMax = nums(i)
        Else
            If nums(i) < oddMin Then oddMin = nums(i)
            If nums(i) > oddMax Then oddMax = nums(i)
        End If
    Next
    
    Dim oddPart As String, evenPart As String
    
    If oddMin <= oddMax Then
        If oddMin = oddMax Then
            oddPart = CStr(oddMin)
        Else
            oddPart = CStr(oddMin) & " à " & CStr(oddMax)
        End If
    End If
    
    If evenMin <= evenMax Then
        If evenMin = evenMax Then
            evenPart = CStr(evenMin)
        Else
            evenPart = CStr(evenMin) & " à " & CStr(evenMax)
        End If
    End If
    
    If oddPart <> "" And evenPart <> "" Then
        CalculateBornesFast = oddPart & " et " & evenPart
    ElseIf oddPart <> "" Then
        CalculateBornesFast = oddPart
    Else
        CalculateBornesFast = evenPart
    End If
End Function

Private Function QuickSortByLastWordArray(arr As Variant) As Variant
    Dim temp As Variant, i As Long, j As Long
    Dim lastWords() As String
    
    If Not IsArray(arr) Then
        QuickSortByLastWordArray = arr
        Exit Function
    End If
    
    temp = arr
    ReDim lastWords(LBound(temp) To UBound(temp))
    
    ' Précalculer les derniers mots
    For i = LBound(temp) To UBound(temp)
        lastWords(i) = UCase$(GetLastWordFast(CStr(temp(i))))
    Next
    
    ' Tri à bulles optimisé
    For i = LBound(temp) To UBound(temp) - 1
        For j = i + 1 To UBound(temp)
            If lastWords(i) > lastWords(j) Then
                ' Échanger les éléments
                Dim tempStr As String
                tempStr = temp(i)
                temp(i) = temp(j)
                temp(j) = tempStr
                
                tempStr = lastWords(i)
                lastWords(i) = lastWords(j)
                lastWords(j) = tempStr
            End If
        Next
    Next
    
    QuickSortByLastWordArray = temp
End Function

Private Sub ApplyFormattingFast(ws As Worksheet, formatArr As Variant, rowCount As Long, _
                               totalCols As Long, nbColumns As Long)
    Dim i As Long, rng As Range
    Dim lastCol As String
    
    lastCol = Chr(64 + totalCols)
    
    ' Formatage en bloc par type
    For i = 1 To rowCount
        Select Case formatArr(i, 1)
            Case 1 ' En-tête noir
                Set rng = ws.Range("A" & i & ":" & lastCol & i)
                With rng
                    .Merge
                    .Interior.Color = vbBlack
                    .Font.Color = vbWhite
                    .Font.Bold = True
                    .HorizontalAlignment = xlCenter
                End With
                
            Case 2 ' En-tête jaune
                Set rng = ws.Range("A" & i & ":" & lastCol & i)
                With rng
                    .Merge
                    .Interior.Color = vbYellow
                    .Font.Bold = True
                    .HorizontalAlignment = xlCenter
                End With
                
            Case 3 ' En-tête bleu
                Set rng = ws.Range("A" & i & ":" & lastCol & i)
                With rng
                    .Merge
                    .Interior.Color = vbBlue
                    .Font.Color = vbWhite
                    .Font.Bold = True
                    .HorizontalAlignment = xlCenter
                End With
                
            Case 10, 11 ' Lignes normales ou vertes
                If nbColumns = 1 Then
                    If formatArr(i, 1) = 11 Then
                        ws.Range("A" & i & ":B" & i).Interior.Color = vbGreen
                        ws.Range("A" & i & ":B" & i).Font.Color = vbWhite
                    ElseIf i Mod 2 = 0 Then
                        ws.Range("A" & i & ":B" & i).Interior.Color = RGB(242, 242, 242)
                    End If
                End If
        End Select
    Next
    
    ' Ajuster les colonnes
    ws.UsedRange.Columns.AutoFit
    
    ' Centrer les colonnes de tournées
    For i = 2 To totalCols Step 2
        ws.Columns(i).HorizontalAlignment = xlCenter
    Next
    
    ' Bordures
    ws.UsedRange.Borders.LineStyle = xlDash
End Sub
