Sub CalculerBornes()
    On Error GoTo ErrorHandler
    
    Dim wsSource As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim resultRow As Long
    
    ' Structure pour stocker les données temporaires
    Dim tempData() As String
    Dim tempCount As Long
    
    ' Variables pour les données de chaque ligne
    Dim tournee As String, libelleDistrict As String, ligne3 As String
    Dim numero As String, motDirecteur As String, voie As String
    Dim commune As String, secable As String, samedi As String
    Dim numeroInt As Long
    
    ' 1. Identifier la feuille source
    Set wsSource = ThisWorkbook.Worksheets(1)
    
    ' 2. Supprimer la feuille "Calcul des bornes" si elle existe
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    ' 3. Créer la nouvelle feuille "Calcul des bornes"
    Set wsResult = ThisWorkbook.Worksheets.Add
    wsResult.Name = "Calcul des bornes"
    
    ' 4. Créer les en-têtes
    With wsResult
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Formatage des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(220, 220, 220)
    End With
    
    ' 5. Lire toutes les données dans un tableau temporaire
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    tempCount = 0
    
    ' Dimensionner le tableau temporaire
    ReDim tempData(1 To lastRow, 1 To 9)
    
    For i = 2 To lastRow
        ' Lire les données de la ligne courante
        tournee = GetCellValue(wsSource.Cells(i, 1))
        libelleDistrict = GetCellValue(wsSource.Cells(i, 2))
        ligne3 = GetCellValue(wsSource.Cells(i, 3))
        numero = GetCellValue(wsSource.Cells(i, 4))
        motDirecteur = GetCellValue(wsSource.Cells(i, 5))
        voie = GetCellValue(wsSource.Cells(i, 6))
        commune = GetCellValue(wsSource.Cells(i, 7))
        secable = GetCellValue(wsSource.Cells(i, 8))
        samedi = GetCellValue(wsSource.Cells(i, 9))
        
        ' Stocker uniquement les lignes avec numéro valide
        If numero <> "" And IsNumeric(numero) Then
            tempCount = tempCount + 1
            tempData(tempCount, 1) = commune
            tempData(tempCount, 2) = motDirecteur
            tempData(tempCount, 3) = voie
            tempData(tempCount, 4) = ligne3
            tempData(tempCount, 5) = numero
            tempData(tempCount, 6) = libelleDistrict
            tempData(tempCount, 7) = tournee
            tempData(tempCount, 8) = secable
            tempData(tempCount, 9) = samedi
        End If
    Next i
    
    ' 6. Traiter les données pour créer les groupes
    resultRow = 2
    Dim processedGroups As String
    processedGroups = ""
    
    For i = 1 To tempCount
        Dim currentGroupKey As String
        currentGroupKey = tempData(i, 1) & "|" & tempData(i, 2) & "|" & tempData(i, 3) ' Commune|MotDirecteur|Voie
        
        ' Vérifier si ce groupe a déjà été traité
        If InStr(processedGroups, currentGroupKey & ";") = 0 Then
            processedGroups = processedGroups & currentGroupKey & ";"
            
            ' Collecter toutes les adresses de ce groupe
            Dim groupData() As String
            Dim groupCount As Long
            groupCount = 0
            
            Dim j As Long
            For j = 1 To tempCount
                If tempData(j, 1) & "|" & tempData(j, 2) & "|" & tempData(j, 3) = currentGroupKey Then
                    groupCount = groupCount + 1
                    ReDim Preserve groupData(1 To groupCount, 1 To 9)
                    Dim k As Long
                    For k = 1 To 9
                        groupData(groupCount, k) = tempData(j, k)
                    Next k
                End If
            Next j
            
            ' Traiter ce groupe
            If groupCount > 0 Then
                TraiterGroupe groupData, groupCount, wsResult, resultRow
            End If
        End If
    Next i
    
    ' 7. Ajuster la largeur des colonnes
    wsResult.Columns("A:I").AutoFit
    
    MsgBox "Calcul des bornes terminé. " & (resultRow - 2) & " lignes générées.", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur ligne " & i & " : " & Err.Description & " (Numéro: " & Err.Number & ")", vbCritical
End Sub

' Fonction pour récupérer la valeur d'une cellule de manière sécurisée
Private Function GetCellValue(cell As Range) As String
    Dim value As Variant
    value = cell.Value
    
    If IsNull(value) Or IsEmpty(value) Then
        GetCellValue = ""
    Else
        GetCellValue = Trim(CStr(value))
    End If
End Function

' Subroutine pour traiter un groupe d'adresses
Private Sub TraiterGroupe(groupData() As String, groupCount As Long, wsResult As Worksheet, ByRef resultRow As Long)
    ' Vérifier si la voie est complète (même tournée, sécable, samedi pour tous)
    Dim refTournee As String, refSecable As String, refSamedi As String
    refTournee = groupData(1, 7)
    refSecable = groupData(1, 8)
    refSamedi = groupData(1, 9)
    
    Dim estComplete As Boolean
    estComplete = True
    
    Dim i As Long
    For i = 2 To groupCount
        If groupData(i, 7) <> refTournee Or _
           groupData(i, 8) <> refSecable Or _
           groupData(i, 9) <> refSamedi Then
            estComplete = False
            Exit For
        End If
    Next i
    
    If estComplete Then
        ' Voie complète : une seule ligne sans borne
        EcrireLigneResultat wsResult, resultRow, _
            groupData(1, 1), groupData(1, 2), groupData(1, 3), _
            groupData(1, 4), "", groupData(1, 6), _
            groupData(1, 7), groupData(1, 8), groupData(1, 9)
        resultRow = resultRow + 1
    Else
        ' Voie non complète : calculer les bornes par sous-groupe
        CalculerBornesParSousGroupe groupData, groupCount, wsResult, resultRow
    End If
End Sub

' Subroutine pour calculer les bornes par sous-groupe
Private Sub CalculerBornesParSousGroupe(groupData() As String, groupCount As Long, wsResult As Worksheet, ByRef resultRow As Long)
    Dim processedSubGroups As String
    processedSubGroups = ""
    
    Dim i As Long
    For i = 1 To groupCount
        Dim subGroupKey As String
        subGroupKey = groupData(i, 7) & "|" & groupData(i, 8) & "|" & groupData(i, 9) ' Tournée|Sécable|Samedi
        
        ' Vérifier si ce sous-groupe a déjà été traité
        If InStr(processedSubGroups, subGroupKey & ";") = 0 Then
            processedSubGroups = processedSubGroups & subGroupKey & ";"
            
            ' Collecter les numéros pairs et impairs pour ce sous-groupe
            Dim pairsList As String, impairsList As String
            pairsList = ""
            impairsList = ""
            
            Dim j As Long
            For j = 1 To groupCount
                If groupData(j, 7) & "|" & groupData(j, 8) & "|" & groupData(j, 9) = subGroupKey Then
                    Dim numero As Long
                    numero = CLng(groupData(j, 5))
                    
                    If numero Mod 2 = 0 Then
                        If pairsList = "" Then
                            pairsList = CStr(numero)
                        Else
                            pairsList = pairsList & "," & CStr(numero)
                        End If
                    Else
                        If impairsList = "" Then
                            impairsList = CStr(numero)
                        Else
                            impairsList = impairsList & "," & CStr(numero)
                        End If
                    End If
                End If
            Next j
            
            ' Écrire les lignes pour ce sous-groupe
            If pairsList <> "" Then
                Dim bornePairs As String
                bornePairs = CalculerBorneDepuisListe(pairsList)
                EcrireLigneResultat wsResult, resultRow, _
                    groupData(i, 1), groupData(i, 2), groupData(i, 3), _
                    groupData(i, 4), bornePairs, groupData(i, 6), _
                    groupData(i, 7), groupData(i, 8), groupData(i, 9)
                resultRow = resultRow + 1
            End If
            
            If impairsList <> "" Then
                Dim borneImpairs As String
                borneImpairs = CalculerBorneDepuisListe(impairsList)
                EcrireLigneResultat wsResult, resultRow, _
                    groupData(i, 1), groupData(i, 2), groupData(i, 3), _
                    groupData(i, 4), borneImpairs, groupData(i, 6), _
                    groupData(i, 7), groupData(i, 8), groupData(i, 9)
                resultRow = resultRow + 1
            End If
        End If
    Next i
End Sub

' Fonction pour calculer une borne à partir d'une liste de numéros
Private Function CalculerBorneDepuisListe(listeNumeros As String) As String
    If listeNumeros = "" Then
        CalculerBorneDepuisListe = ""
        Exit Function
    End If
    
    ' Séparer et trier les numéros
    Dim numerosArray As Variant
    numerosArray = Split(listeNumeros, ",")
    
    ' Convertir en tableau de Long
    Dim numArray() As Long
    ReDim numArray(0 To UBound(numerosArray))
    
    Dim i As Long, j As Long, temp As Long
    For i = 0 To UBound(numerosArray)
        numArray(i) = CLng(numerosArray(i))
    Next i
    
    ' Tri par sélection simple
    For i = 0 To UBound(numArray) - 1
        For j = i + 1 To UBound(numArray)
            If numArray(i) > numArray(j) Then
                temp = numArray(i)
                numArray(i) = numArray(j)
                numArray(j) = temp
            End If
        Next j
    Next i
    
    ' Retourner la borne formatée
    If UBound(numArray) = 0 Then
        CalculerBorneDepuisListe = CStr(numArray(0))
    Else
        CalculerBorneDepuisListe = CStr(numArray(0)) & " → " & CStr(numArray(UBound(numArray)))
    End If
End Function

' Subroutine pour écrire une ligne de résultat
Private Sub EcrireLigneResultat(ws As Worksheet, row As Long, _
    commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, borne As String, libelleDistrict As String, _
    tournee As String, secable As String, samedi As String)
    
    With ws
        .Cells(row, 1).Value = commune
        .Cells(row, 2).Value = motDirecteur
        .Cells(row, 3).Value = voie
        .Cells(row, 4).Value = ligne3
        .Cells(row, 5).Value = borne
        .Cells(row, 6).Value = libelleDistrict
        .Cells(row, 7).Value = tournee
        .Cells(row, 8).Value = secable
        .Cells(row, 9).Value = samedi
    End With
End Sub
