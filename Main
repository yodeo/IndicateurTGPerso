Option Explicit

' --- Globals ---
Public g_wsSrc      As Worksheet
Public g_dataArr    As Variant
Public g_colComm    As Long
Public g_colVoie    As Long
Public g_colNum     As Long
Public g_colTour    As Long
Public g_colSecable As Long
Public g_colLigne   As Long
Public g_colLigne3  As Long

' === STRUCTURES DE DONNÉES OPTIMISÉES ===
Private Type TourneeInfo
    commune As String
    voie As String
    tournee As String
    nums() As Long
    numCount As Long
    ligneText As String
    ligne3Text As String
    isMultiTournee As Boolean
End Type

' === API Windows pour mesurer le temps ===
#If VBA7 Then
    Private Declare PtrSafe Function GetTickCount Lib "kernel32" () As Long
#Else
    Private Declare Function GetTickCount Lib "kernel32" () As Long
#End If

' === FONCTION PRINCIPALE ULTRA-OPTIMISÉE ===
Public Sub GenererIndicateurTournées()
    Dim startTime As Long
    startTime = GetTickCount
    
    Dim nbColumns As Long, mode As Long
    Dim wsOut As Worksheet
    Dim useToutSauf As Boolean
    
    ' Interface utilisateur
    nbColumns = Application.InputBox( _
        "Nombre de colonnes pour l'affichage ?" & vbCrLf & _
        "(1 = mode simple, 2+ = mode multi-colonnes)", _
        "Configuration de l'affichage", 1, Type:=1)
    If nbColumns < 1 Then
        MsgBox "Le nombre de colonnes doit être au moins 1.", vbExclamation
        Exit Sub
    End If

    mode = Application.InputBox( _
        "Mode d'affichage :" & vbCrLf & _
        "1 = Standard (toutes les voies)" & vbCrLf & _
        "2 = Tout sauf (masquer les voies majoritaires)", _
        "Mode d'affichage", 1, Type:=1)
    If mode <> 1 And mode <> 2 Then
        MsgBox "Mode invalide.", vbExclamation
        Exit Sub
    End If
    useToutSauf = (mode = 2)
    
    ' Optimisations Excel
    With Application
        .ScreenUpdating = False
        .Calculation = xlCalculationManual
        .EnableEvents = False
        .DisplayStatusBar = False
        .PrintCommunication = False
    End With
    
    ' Créer la feuille de sortie
    On Error Resume Next
    Application.DisplayAlerts = False
    Worksheets("indicateur de tg à vérifier").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0
    
    Set wsOut = Worksheets.Add(After:=Sheets(Sheets.Count))
    wsOut.Name = "indicateur de tg à vérifier"
    
    ' Traitement principal
    ProcessDataUltraFast ActiveSheet, wsOut, nbColumns, useToutSauf
    
    ' Restaurer Excel
    With Application
        .ScreenUpdating = True
        .Calculation = xlCalculationAutomatic
        .EnableEvents = True
        .DisplayStatusBar = True
        .PrintCommunication = True
    End With
    
    Dim elapsedTime As Long
    elapsedTime = GetTickCount - startTime
    MsgBox "Indicateur généré avec " & nbColumns & " colonne(s) dans 'indicateur de tg à vérifier'." & _
           vbCrLf & "Temps d'exécution : " & Format(elapsedTime / 1000, "0.00") & " secondes", vbInformation
End Sub

' === TRAITEMENT PRINCIPAL ULTRA-RAPIDE ===
Private Sub ProcessDataUltraFast(wsSource As Worksheet, wsOut As Worksheet, _
                                nbColumns As Long, useToutSauf As Boolean)
    
    Dim dataArr    As Variant
    Dim outputArr() As Variant
    Dim formatArr() As Variant
    Dim rowCount   As Long, colCount As Long
    Dim i As Long, j As Long, outputRow As Long
    Dim totalCols  As Long
    
    ' ——— Charger toutes les données en mémoire ———
    Dim ur As Range
    Set ur = wsSource.UsedRange
    
    ' Comptage de lignes et colonnes
    rowCount = ur.Rows.Count
    colCount = ur.Columns.Count
    
    ' Toujours créer dataArr en 2D
    If rowCount = 1 And colCount = 1 Then
        ReDim dataArr(1 To 1, 1 To 1)
        dataArr(1, 1) = ur.Value
    Else
        dataArr = ur.Value
    End If
    
    ' Identifier les colonnes d'en-tête
    Dim colMap(1 To 7) As Long
    For j = 1 To colCount
        Select Case UCase$(Trim$(CStr(dataArr(1, j))))
            Case "COMMUNE":       colMap(1) = j
            Case "VOIE":          colMap(2) = j
            Case "NUMÉRO", "NUMERO":   colMap(3) = j
            Case "TOURNÉE", "TOURNEE": colMap(4) = j
            Case "SÉCABLE", "SECABLE": colMap(5) = j
            Case "LIGNE":         colMap(6) = j
            Case "LIGNE 3":       colMap(7) = j
        End Select
    Next j
    
    If colMap(1) * colMap(2) * colMap(3) * colMap(4) = 0 Then
        MsgBox "Colonnes obligatoires introuvables", vbCritical
        Exit Sub
    End If
    
    ' — Prétraitement : structuration en dictionnaires —
    Dim dataDict As Object
    Set dataDict = CreateObject("Scripting.Dictionary")
    
    Dim commune As String, voie As String, tournee As String, numero As String
    Dim secable As String, ligne As String, ligne3 As String
    Dim key As String, keyStr As String
    
    For i = 2 To rowCount
        commune = Trim$(CStr(dataArr(i, colMap(1))))
        voie    = Trim$(CStr(dataArr(i, colMap(2))))
        numero  = Trim$(CStr(dataArr(i, colMap(3))))
        tournee = Trim$(CStr(dataArr(i, colMap(4))))
        
        If colMap(5) > 0 Then
            secable = Trim$(CStr(dataArr(i, colMap(5))))
            If Len(secable) > 0 Then tournee = tournee & " (" & secable & ")"
        End If
        
        key = commune & "|" & voie & "|" & tournee
        If Not dataDict.Exists(key) Then
            dataDict.Add key, CreateObject("Scripting.Dictionary")
            dataDict(key)("nums")   = CreateObject("Scripting.Dictionary")
            dataDict(key)("ligne")  = ""
            dataDict(key)("ligne3") = CreateObject("Scripting.Dictionary")
        End If
        
        If IsNumeric(numero) Then
            dataDict(key)("nums")(CLng(numero)) = True
        End If
        
        If colMap(6) > 0 Then
            ligne = Trim$(CStr(dataArr(i, colMap(6))))
            If Len(ligne) > 0 And dataDict(key)("ligne") = "" Then
                dataDict(key)("ligne") = ligne
            End If
        End If
        
        If colMap(7) > 0 Then
            ligne3 = Trim$(CStr(dataArr(i, colMap(7))))
            If Len(ligne3) > 0 Then
                dataDict(key)("ligne3")(ligne3) = True
            End If
        End If
    Next i
    
    ' — Génération du tableau de sortie —
    totalCols = nbColumns * 2
    ReDim outputArr(1 To rowCount, 1 To totalCols)
    ReDim formatArr(1 To rowCount, 1 To 5)
    
    outputRow = 0
    Dim communes As Object
    Set communes = CreateObject("Scripting.Dictionary")
    
    ' Regrouper par commune
    For Each key In dataDict.Keys
        Dim parts() As String
        parts = Split(key, "|")
        commune = parts(0)
        If Not communes.Exists(commune) Then
            Set communes(commune) = CreateObject("Scripting.Dictionary")
        End If
        communes(commune)(key) = True
    Next
    
    ' Trier les communes
    Dim communeKeys As Variant
    communeKeys = QuickSortByLastWordArray(communes.Keys)
    
    ' Pour chaque commune, on construit les lignes...
    For Each commune In communeKeys
        outputRow = outputRow + 1
        outputArr(outputRow, 1) = commune
        formatArr(outputRow, 1) = 1
        
        ' … ici, tout le reste de votre logique
        '   (regroupement par voie, calcul des bornes, remplissage de outputArr)
    Next
    
    ' — Écrire et formater en une seule fois —
    If outputRow > 0 Then
        wsOut.Range("A1").Resize(outputRow, totalCols).Value = outputArr
        ApplyFormattingFast wsOut, formatArr, outputRow, totalCols, nbColumns
    End If
End Sub

' === FONCTIONS UTILITAIRES (inchangées) ===
Private Function GetLastWordFast(ByVal txt As String) As String
    Dim pos As Long
    pos = InStrRev(txt, " ")
    If pos > 0 Then
        GetLastWordFast = Mid$(txt, pos + 1)
    Else
        GetLastWordFast = txt
    End If
End Function

Private Function GetAbbreviatedFast(ByVal voie As String) As String
    '… votre code existant …
End Function

Private Function CalculateBornesFast(ByVal numsDict As Variant) As String
    '… votre code existant …
End Function

Private Function QuickSortByLastWordArray(arr As Variant) As Variant
    '… votre code existant …
End Function

Private Sub ApplyFormattingFast(ws As Worksheet, formatArr As Variant, _
                                rowCount As Long, totalCols As Long, nbColumns As Long)
    '… votre code existant …
End Sub
