Sub CalculerBornes()
    '=========================================================================
    ' VERSION CORRIGÉE - ÉVITE LES VRAIS CHEVAUCHEMENTS (même parité)
    ' Créé des plages non-chevauchantes en regroupant les numéros consécutifs
    '=========================================================================
    
    Dim ws As Worksheet
    Dim wsCalcul As Worksheet
    Dim lastRow As Long
    Dim i As Long, j As Long
    Dim ligneResultat As Long
    
    ' 1. IDENTIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Set ws = Nothing
    Dim wsTemp As Worksheet
    
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name <> "Calcul des bornes" Then
            Dim h1 As String, h4 As String, h6 As String, h7 As String
            h1 = CellToString(wsTemp.Cells(1, 1))
            h4 = CellToString(wsTemp.Cells(1, 4))
            h6 = CellToString(wsTemp.Cells(1, 6))
            h7 = CellToString(wsTemp.Cells(1, 7))
            
            If (InStr(UCase(h1), "TOURN") > 0) And _
               (InStr(UCase(h4), "NUM") > 0) And _
               (InStr(UCase(h6), "VOIE") > 0) And _
               (InStr(UCase(h7), "COMM") > 0) Then
                Set ws = wsTemp
                Exit For
            End If
        End If
    Next wsTemp
    
    If ws Is Nothing Then
        MsgBox "Feuille source non trouvée !", vbCritical
        Exit Sub
    End If
    
    ' 2. CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    Application.DisplayAlerts = False
    Set wsCalcul = Nothing
    For Each wsTemp In ThisWorkbook.Worksheets
        If wsTemp.Name = "Calcul des bornes" Then
            wsTemp.Delete
            Exit For
        End If
    Next wsTemp
    Application.DisplayAlerts = True
    
    Set wsCalcul = ThisWorkbook.Worksheets.Add
    wsCalcul.Name = "Calcul des bornes"
    
    ' En-têtes
    wsCalcul.Cells(1, 1) = "Commune"
    wsCalcul.Cells(1, 2) = "Mot directeur"
    wsCalcul.Cells(1, 3) = "Libelle de voie"
    wsCalcul.Cells(1, 4) = "Ligne 3"
    wsCalcul.Cells(1, 5) = "Numéro de voie (borne)"
    wsCalcul.Cells(1, 6) = "Libelle District"
    wsCalcul.Cells(1, 7) = "Tournée"
    wsCalcul.Cells(1, 8) = "Sécable"
    wsCalcul.Cells(1, 9) = "Samedi"
    
    wsCalcul.Range("A1:I1").Font.Bold = True
    wsCalcul.Range("A1:I1").Interior.Color = RGB(180, 198, 231)
    
    ' 3. TRAITEMENT VOIE PAR VOIE
    '=========================================================================
    lastRow = ws.Cells(ws.Rows.Count, 1).End(xlUp).row
    ligneResultat = 2
    
    ' Array pour marquer les voies déjà traitées
    ReDim voiesTraitees(1 To lastRow) As Boolean
    
    ' Parcourir chaque ligne et traiter les voies une par une
    For i = 2 To lastRow
        If Not voiesTraitees(i) Then
            Dim commune As String, voie As String, motDirecteur As String
            Dim ligne3 As String, libelleDistrict As String
            
            commune = CellToString(ws.Cells(i, 7))
            voie = CellToString(ws.Cells(i, 6))
            motDirecteur = CellToString(ws.Cells(i, 5))
            ligne3 = CellToString(ws.Cells(i, 3))
            libelleDistrict = CellToString(ws.Cells(i, 2))
            
            If commune <> "" And voie <> "" Then
                voiesTraitees(i) = True
                Call TraiterVoieSansChevaucher(ws, wsCalcul, commune, voie, motDirecteur, ligne3, libelleDistrict, ligneResultat, voiesTraitees, lastRow)
            End If
        End If
    Next i
    
    ' 4. MISE EN FORME FINALE
    '=========================================================================
    Dim nbResultats As Long
    nbResultats = ligneResultat - 2
    
    With wsCalcul
        .Columns("A:I").AutoFit
        If nbResultats > 0 Then
            .Range("A1:I" & ligneResultat - 1).Borders.LineStyle = xlContinuous
        End If
        .Range("A1:I1").HorizontalAlignment = xlCenter
        .Range("A1").Select
    End With
    
    MsgBox "Calcul terminé !" & vbCrLf & "Lignes générées: " & nbResultats, vbInformation
End Sub

Function CellToString(ByVal cell As Range) As String
    Dim valeur As Variant
    valeur = cell.value
    
    If IsEmpty(valeur) Or IsNull(valeur) Then
        CellToString = ""
    ElseIf IsError(valeur) Then
        CellToString = ""
    Else
        CellToString = Trim(CStr(valeur))
    End If
End Function

Sub TraiterVoieSansChevaucher(ByRef ws As Worksheet, ByRef wsCalcul As Worksheet, _
                              ByVal commune As String, ByVal voie As String, ByVal motDirecteur As String, _
                              ByVal ligne3 As String, ByVal libelleDistrict As String, _
                              ByRef ligneResultat As Long, ByRef voiesTraitees() As Boolean, ByVal lastRow As Long)
    
    ' Collecter toutes les données de la voie avec leur position dans le fichier
    ReDim donneesVoie(1 To 1000, 1 To 5) As Variant
    Dim nbDonnees As Long
    nbDonnees = 0
    
    Dim i As Long
    For i = 2 To lastRow
        Dim communeLigne As String, voieLigne As String
        communeLigne = CellToString(ws.Cells(i, 7))
        voieLigne = CellToString(ws.Cells(i, 6))
        
        If communeLigne = commune And voieLigne = voie Then
            voiesTraitees(i) = True
            
            Dim numero As Variant
            numero = ws.Cells(i, 4).value
            
            If IsNumeric(numero) And numero > 0 Then
                nbDonnees = nbDonnees + 1
                donneesVoie(nbDonnees, 1) = CellToString(ws.Cells(i, 1)) ' Tournée
                donneesVoie(nbDonnees, 2) = CellToString(ws.Cells(i, 8)) ' Sécable
                donneesVoie(nbDonnees, 3) = CellToString(ws.Cells(i, 9)) ' Samedi
                donneesVoie(nbDonnees, 4) = CLng(numero)                 ' Numéro
                donneesVoie(nbDonnees, 5) = i                            ' Ligne source (pour tri stable)
            End If
        End If
    Next i
    
    If nbDonnees = 0 Then Exit Sub
    
    ' Séparer pairs et impairs et créer des groupes consécutifs non-chevauchants
    Call TraiterParite(wsCalcul, commune, voie, motDirecteur, ligne3, libelleDistrict, _
                       donneesVoie, nbDonnees, True, ligneResultat)  ' Impairs
    Call TraiterParite(wsCalcul, commune, voie, motDirecteur, ligne3, libelleDistrict, _
                       donneesVoie, nbDonnees, False, ligneResultat) ' Pairs
End Sub

Sub TraiterParite(ByRef wsCalcul As Worksheet, ByVal commune As String, ByVal voie As String, _
                  ByVal motDirecteur As String, ByVal ligne3 As String, ByVal libelleDistrict As String, _
                  ByRef donneesVoie As Variant, ByVal nbDonnees As Long, ByVal estImpair As Boolean, _
                  ByRef ligneResultat As Long)
    
    ' Filtrer et trier les numéros de la parité demandée
    ReDim numerosParite(1 To 1000, 1 To 4) As Variant
    Dim nbParite As Long
    nbParite = 0
    
    Dim i As Long
    For i = 1 To nbDonnees
        Dim numero As Long
        numero = donneesVoie(i, 4)
        
        If (estImpair And numero Mod 2 = 1) Or (Not estImpair And numero Mod 2 = 0) Then
            nbParite = nbParite + 1
            numerosParite(nbParite, 1) = donneesVoie(i, 1) ' Tournée
            numerosParite(nbParite, 2) = donneesVoie(i, 2) ' Sécable
            numerosParite(nbParite, 3) = donneesVoie(i, 3) ' Samedi
            numerosParite(nbParite, 4) = numero             ' Numéro
        End If
    Next i
    
    If nbParite = 0 Then Exit Sub
    
    ' Trier par numéro croissant
    Call TrierTableau(numerosParite, nbParite)
    
    ' Créer un dictionnaire global de tous les numéros existants pour cette parité
    Dim tousLesNumerosExistants As Object
    Set tousLesNumerosExistants = CreateObject("Scripting.Dictionary")
    
    For i = 1 To nbParite
        Dim numeroExistant As Long
        numeroExistant = numerosParite(i, 4)
        If Not tousLesNumerosExistants.Exists(numeroExistant) Then
            tousLesNumerosExistants.Add numeroExistant, True
        End If
    Next i
    
    ' Créer des groupes par combinaison tournée/sécable/samedi
    Dim groupes As Object
    Set groupes = CreateObject("Scripting.Dictionary")
    
    For i = 1 To nbParite
        Dim tournee As String, secable As String, samedi As String, numero As Long
        tournee = numerosParite(i, 1)
        secable = numerosParite(i, 2)
        samedi = numerosParite(i, 3)
        numero = numerosParite(i, 4)
        
        Dim cleCombo As String
        cleCombo = tournee & "|" & secable & "|" & samedi
        
        If Not groupes.Exists(cleCombo) Then
            Dim nouveauGroupe As Object
            Set nouveauGroupe = CreateObject("Scripting.Dictionary")
            nouveauGroupe.Add "tournee", tournee
            nouveauGroupe.Add "secable", secable
            nouveauGroupe.Add "samedi", samedi
            nouveauGroupe.Add "numeros", CreateObject("System.Collections.ArrayList")
            groupes.Add cleCombo, nouveauGroupe
        End If
        
        groupes(cleCombo)("numeros").Add numero
    Next i
    
    ' Pour chaque groupe, créer des plages intelligentes
    Dim cleGroupe As Variant
    For Each cleGroupe In groupes.Keys
        Dim groupe As Object
        Set groupe = groupes(cleGroupe)
        
        Dim numerosGroupe As Object
        Set numerosGroupe = groupe("numeros")
        
        ' Convertir en array et trier
        ReDim arrayNumeros(0 To numerosGroupe.Count - 1) As Long
        For i = 0 To numerosGroupe.Count - 1
            arrayNumeros(i) = numerosGroupe(i)
        Next i
        Call TrierArray(arrayNumeros)
        
        ' Créer des plages continues, coupées seulement si un numéro intermédiaire existe dans une autre combinaison
        If UBound(arrayNumeros) >= 0 Then
            Dim debut As Long, fin As Long
            debut = arrayNumeros(0)
            fin = arrayNumeros(0)
            
            For i = 1 To UBound(arrayNumeros)
                Dim numeroActuel As Long
                numeroActuel = arrayNumeros(i)
                
                ' Vérifier s'il y a des numéros de cette parité qui existent dans D'AUTRES combinaisons
                ' entre fin et numeroActuel
                Dim doitCouper As Boolean
                doitCouper = False
                Dim numeroOuCouper As Long
                numeroOuCouper = 0
                
                ' Créer un dictionnaire des numéros de CETTE combinaison pour vérification
                Dim numerosDeCetteCombinaison As Object
                Set numerosDeCetteCombinaison = CreateObject("Scripting.Dictionary")
                Dim j As Long
                For j = 0 To UBound(arrayNumeros)
                    If Not numerosDeCetteCombinaison.Exists(arrayNumeros(j)) Then
                        numerosDeCetteCombinaison.Add arrayNumeros(j), True
                    End If
                Next j
                
                ' Parcourir tous les numéros de cette parité entre fin et numeroActuel
                Dim numeroIntermediaire As Long
                Dim pas As Long
                pas = IIf(estImpair, 2, 2) ' Pas de 2 pour pairs et impairs
                
                For numeroIntermediaire = fin + pas To numeroActuel - pas Step pas
                    ' Si ce numéro intermédiaire existe dans les données globales
                    ' ET qu'il n'appartient PAS à cette combinaison
                    If tousLesNumerosExistants.Exists(numeroIntermediaire) And _
                       Not numerosDeCetteCombinaison.Exists(numeroIntermediaire) Then
                        ' Ce numéro appartient à une autre combinaison, il faut couper
                        doitCouper = True
                        numeroOuCouper = numeroIntermediaire
                        Exit For
                    End If
                Next numeroIntermediaire
                
                If doitCouper Then
                    ' Ajuster la fin de la plage actuelle pour s'arrêter juste avant le conflit
                    Dim nouvelleFin As Long
                    If estImpair Then
                        nouvelleFin = numeroOuCouper - 2
                    Else
                        nouvelleFin = numeroOuCouper - 2
                    End If
                    
                    ' S'assurer que nouvelleFin >= debut et <= fin actuel
                    If nouvelleFin >= debut And nouvelleFin <= fin Then
                        fin = nouvelleFin
                    End If
                    
                    ' Finaliser la plage actuelle
                    Call EcrireLigneBorne(wsCalcul, commune, motDirecteur, voie, ligne3, libelleDistrict, _
                                          debut, fin, groupe("tournee"), groupe("secable"), groupe("samedi"), ligneResultat)
                    
                    ' Commencer une nouvelle plage à partir du numéro actuel
                    debut = numeroActuel
                    fin = numeroActuel
                Else
                    ' Aucun conflit détecté, continuer la plage jusqu'au numéro actuel
                    ' (même s'il y a des "trous" naturels)
                    fin = numeroActuel
                End If
            Next i
            
            ' Écrire la dernière plage
            Call EcrireLigneBorne(wsCalcul, commune, motDirecteur, voie, ligne3, libelleDistrict, _
                                  debut, fin, groupe("tournee"), groupe("secable"), groupe("samedi"), ligneResultat)
        End If
    Next cleGroupe
End Sub

Sub EcrireLigneBorne(ByRef wsCalcul As Worksheet, ByVal commune As String, ByVal motDirecteur As String, _
                     ByVal voie As String, ByVal ligne3 As String, ByVal libelleDistrict As String, _
                     ByVal debut As Long, ByVal fin As Long, ByVal tournee As String, _
                     ByVal secable As String, ByVal samedi As String, ByRef ligneResultat As Long)
    
    Dim borne As String
    If debut = fin Then
        borne = CStr(debut)
    Else
        borne = debut & " à " & fin
    End If
    
    wsCalcul.Cells(ligneResultat, 1) = commune
    wsCalcul.Cells(ligneResultat, 2) = motDirecteur
    wsCalcul.Cells(ligneResultat, 3) = voie
    wsCalcul.Cells(ligneResultat, 4) = ligne3
    wsCalcul.Cells(ligneResultat, 5) = borne
    wsCalcul.Cells(ligneResultat, 6) = libelleDistrict
    wsCalcul.Cells(ligneResultat, 7) = tournee
    wsCalcul.Cells(ligneResultat, 8) = secable
    wsCalcul.Cells(ligneResultat, 9) = samedi
    
    ligneResultat = ligneResultat + 1
End Sub

Sub TrierTableau(ByRef tableau As Variant, ByVal nbElements As Long)
    ' Tri à bulles simple sur la colonne 4 (numéro)
    Dim i As Long, j As Long
    Dim temp1 As Variant, temp2 As Variant, temp3 As Variant, temp4 As Variant
    
    For i = 1 To nbElements - 1
        For j = 1 To nbElements - i
            If tableau(j, 4) > tableau(j + 1, 4) Then
                ' Échanger les lignes
                temp1 = tableau(j, 1)
                temp2 = tableau(j, 2)
                temp3 = tableau(j, 3)
                temp4 = tableau(j, 4)
                
                tableau(j, 1) = tableau(j + 1, 1)
                tableau(j, 2) = tableau(j + 1, 2)
                tableau(j, 3) = tableau(j + 1, 3)
                tableau(j, 4) = tableau(j + 1, 4)
                
                tableau(j + 1, 1) = temp1
                tableau(j + 1, 2) = temp2
                tableau(j + 1, 3) = temp3
                tableau(j + 1, 4) = temp4
            End If
        Next j
    Next i
End Sub

Sub TrierArray(ByRef arr As Variant)
    ' Tri à bulles pour array simple
    Dim i As Long, j As Long, temp As Long
    
    For i = LBound(arr) To UBound(arr) - 1
        For j = LBound(arr) To UBound(arr) - 1
            If arr(j) > arr(j + 1) Then
                temp = arr(j)
                arr(j) = arr(j + 1)
                arr(j + 1) = temp
            End If
        Next j
    Next i
End Sub
