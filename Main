Sub CalculerBornes()
    On Error GoTo ErrorHandler
    
    Dim wsSource As Worksheet
    Dim wsResult As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim resultRow As Long
    Dim errorLine As Long
    errorLine = 0
    
    ' 1. Identifier la feuille source
    Set wsSource = ThisWorkbook.Worksheets(1)
    
    ' 2. Supprimer la feuille "Calcul des bornes" si elle existe
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Calcul des bornes").Delete
    On Error GoTo ErrorHandler
    Application.DisplayAlerts = True
    
    ' 3. Créer la nouvelle feuille "Calcul des bornes"
    Set wsResult = ThisWorkbook.Worksheets.Add
    wsResult.Name = "Calcul des bornes"
    
    ' 4. Créer les en-têtes
    With wsResult
        .Cells(1, 1).Value = "Commune"
        .Cells(1, 2).Value = "Mot directeur"
        .Cells(1, 3).Value = "Libelle de voie"
        .Cells(1, 4).Value = "Ligne 3"
        .Cells(1, 5).Value = "Numéro de voie (borne)"
        .Cells(1, 6).Value = "Libelle District"
        .Cells(1, 7).Value = "Tournée"
        .Cells(1, 8).Value = "Sécable"
        .Cells(1, 9).Value = "Samedi"
        
        ' Formatage des en-têtes
        .Range("A1:I1").Font.Bold = True
        .Range("A1:I1").Interior.Color = RGB(220, 220, 220)
    End With
    
    ' 5. Déterminer la dernière ligne avec des données
    lastRow = wsSource.Cells(wsSource.Rows.Count, "A").End(xlUp).Row
    
    If lastRow < 2 Then
        MsgBox "Aucune donnée trouvée dans la feuille source.", vbWarning
        Exit Sub
    End If
    
    ' 6. Lire et traiter les données ligne par ligne de manière sécurisée
    resultRow = 2
    Dim groupesTraites As String
    groupesTraites = "|"
    
    For i = 2 To lastRow
        errorLine = i
        
        ' Lire chaque cellule de manière sécurisée
        Dim tournee As String, libelleDistrict As String, ligne3 As String
        Dim numero As String, motDirecteur As String, voie As String
        Dim commune As String, secable As String, samedi As String
        
        tournee = LireCelluleSafe(wsSource, i, 1)
        libelleDistrict = LireCelluleSafe(wsSource, i, 2)
        ligne3 = LireCelluleSafe(wsSource, i, 3)
        numero = LireCelluleSafe(wsSource, i, 4)
        motDirecteur = LireCelluleSafe(wsSource, i, 5)
        voie = LireCelluleSafe(wsSource, i, 6)
        commune = LireCelluleSafe(wsSource, i, 7)
        secable = LireCelluleSafe(wsSource, i, 8)
        samedi = LireCelluleSafe(wsSource, i, 9)
        
        ' Vérifier que nous avons les données essentielles
        If numero <> "" And IsNumeric(numero) And commune <> "" And voie <> "" Then
            Dim cleGroupe As String
            cleGroupe = commune & "§" & motDirecteur & "§" & voie
            
            ' Traiter chaque groupe une seule fois
            If InStr(groupesTraites, "|" & cleGroupe & "|") = 0 Then
                groupesTraites = groupesTraites & cleGroupe & "|"
                TraiterGroupeRobuste wsSource, cleGroupe, lastRow, wsResult, resultRow
            End If
        End If
    Next i
    
    ' 7. Ajuster la largeur des colonnes
    wsResult.Columns("A:I").AutoFit
    
    MsgBox "Calcul des bornes terminé. " & (resultRow - 2) & " lignes générées.", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "Erreur ligne " & errorLine & " : " & Err.Description & " (Code: " & Err.Number & ")" & vbCrLf & _
           "Vérifiez les données de cette ligne dans la feuille source.", vbCritical
End Sub

' Fonction pour lire une cellule de manière ultra-sécurisée
Private Function LireCelluleSafe(ws As Worksheet, ligne As Long, colonne As Long) As String
    On Error Resume Next
    
    Dim valeur As Variant
    valeur = ws.Cells(ligne, colonne).Value
    
    If Err.Number <> 0 Then
        LireCelluleSafe = ""
        Err.Clear
        Exit Function
    End If
    
    If IsNull(valeur) Then
        LireCelluleSafe = ""
    ElseIf IsEmpty(valeur) Then
        LireCelluleSafe = ""
    ElseIf VarType(valeur) = vbError Then
        LireCelluleSafe = ""
    Else
        LireCelluleSafe = Trim(CStr(valeur))
    End If
    
    On Error GoTo 0
End Function

' Subroutine pour traiter un groupe de manière robuste
Private Sub TraiterGroupeRobuste(wsSource As Worksheet, cleGroupe As String, lastRow As Long, wsResult As Worksheet, ByRef resultRow As Long)
    On Error Resume Next
    
    ' Extraire les éléments de la clé du groupe
    Dim partiesGroupe As Variant
    partiesGroupe = Split(cleGroupe, "§")
    Dim communeCible As String, motDirecteurCible As String, voieCible As String
    communeCible = partiesGroupe(0)
    motDirecteurCible = partiesGroupe(1)
    voieCible = partiesGroupe(2)
    
    ' Collecter toutes les adresses valides de ce groupe
    Dim adressesGroupe As String
    Dim premiereInfo As String
    adressesGroupe = ""
    premiereInfo = ""
    
    Dim i As Long
    For i = 2 To lastRow
        Dim commune As String, motDirecteur As String, voie As String, numero As String
        commune = LireCelluleSafe(wsSource, i, 7)
        motDirecteur = LireCelluleSafe(wsSource, i, 5)
        voie = LireCelluleSafe(wsSource, i, 6)
        numero = LireCelluleSafe(wsSource, i, 4)
        
        ' Vérifier si cette ligne appartient au groupe
        If commune = communeCible And motDirecteur = motDirecteurCible And voie = voieCible Then
            If numero <> "" And IsNumeric(numero) Then
                Dim tournee As String, secable As String, samedi As String
                Dim libelleDistrict As String, ligne3 As String
                
                tournee = LireCelluleSafe(wsSource, i, 1)
                secable = LireCelluleSafe(wsSource, i, 8)
                samedi = LireCelluleSafe(wsSource, i, 9)
                libelleDistrict = LireCelluleSafe(wsSource, i, 2)
                ligne3 = LireCelluleSafe(wsSource, i, 3)
                
                ' Normaliser les valeurs vides pour la comparaison
                If tournee = "" Then tournee = "VIDE"
                If secable = "" Then secable = "VIDE"
                If samedi = "" Then samedi = "VIDE"
                
                ' Stocker l'information de l'adresse
                Dim infoAdresse As String
                infoAdresse = numero & ";" & tournee & ";" & secable & ";" & samedi
                
                If adressesGroupe = "" Then
                    adressesGroupe = infoAdresse
                    premiereInfo = libelleDistrict & ";" & ligne3
                Else
                    adressesGroupe = adressesGroupe & "|" & infoAdresse
                End If
            End If
        End If
    Next i
    
    ' Traiter le groupe si nous avons des adresses
    If adressesGroupe <> "" Then
        EcrireResultatGroupe communeCible, motDirecteurCible, voieCible, premiereInfo, adressesGroupe, wsResult, resultRow
    End If
    
    On Error GoTo 0
End Sub

' Subroutine pour écrire le résultat d'un groupe
Private Sub EcrireResultatGroupe(commune As String, motDirecteur As String, voie As String, _
    premiereInfo As String, adressesGroupe As String, wsResult As Worksheet, ByRef resultRow As Long)
    
    ' Extraire les informations communes
    Dim infoParties As Variant
    infoParties = Split(premiereInfo, ";")
    Dim libelleDistrict As String, ligne3 As String
    libelleDistrict = infoParties(0)
    If UBound(infoParties) >= 1 Then ligne3 = infoParties(1)
    
    ' Analyser les adresses
    Dim adresses As Variant
    adresses = Split(adressesGroupe, "|")
    
    ' Vérifier la complétude de la voie
    Dim premiereAdresse As Variant
    premiereAdresse = Split(adresses(0), ";")
    Dim refTournee As String, refSecable As String, refSamedi As String
    refTournee = premiereAdresse(1)
    refSecable = premiereAdresse(2)
    refSamedi = premiereAdresse(3)
    
    Dim estComplete As Boolean
    estComplete = True
    
    Dim i As Long
    For i = 1 To UBound(adresses)
        Dim autreAdresse As Variant
        autreAdresse = Split(adresses(i), ";")
        
        If autreAdresse(1) <> refTournee Or autreAdresse(2) <> refSecable Or autreAdresse(3) <> refSamedi Then
            estComplete = False
            Exit For
        End If
    Next i
    
    ' Dénormaliser les valeurs pour l'affichage
    If refTournee = "VIDE" Then refTournee = ""
    If refSecable = "VIDE" Then refSecable = ""
    If refSamedi = "VIDE" Then refSamedi = ""
    
    If estComplete Then
        ' Voie complète
        EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, "", _
            libelleDistrict, refTournee, refSecable, refSamedi
        resultRow = resultRow + 1
    Else
        ' Voie incomplète - calculer les bornes
        CalculerBornesIncompletes commune, motDirecteur, voie, ligne3, libelleDistrict, adresses, wsResult, resultRow
    End If
End Sub

' Subroutine pour calculer les bornes des voies incomplètes
Private Sub CalculerBornesIncompletes(commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, libelleDistrict As String, adresses As Variant, wsResult As Worksheet, ByRef resultRow As Long)
    
    Dim sousGroupesTraites As String
    sousGroupesTraites = "|"
    
    Dim i As Long
    For i = 0 To UBound(adresses)
        Dim adresseCourante As Variant
        adresseCourante = Split(adresses(i), ";")
        
        Dim cleSousGroupe As String
        cleSousGroupe = adresseCourante(1) & "§" & adresseCourante(2) & "§" & adresseCourante(3)
        
        If InStr(sousGroupesTraites, "|" & cleSousGroupe & "|") = 0 Then
            sousGroupesTraites = sousGroupesTraites & cleSousGroupe & "|"
            
            ' Collecter les numéros pairs et impairs
            Dim listePairs As String, listeImpairs As String
            listePairs = ""
            listeImpairs = ""
            
            Dim j As Long
            For j = 0 To UBound(adresses)
                Dim autreAdresse As Variant
                autreAdresse = Split(adresses(j), ";")
                
                Dim autreCle As String
                autreCle = autreAdresse(1) & "§" & autreAdresse(2) & "§" & autreAdresse(3)
                
                If autreCle = cleSousGroupe Then
                    Dim numero As Long
                    numero = CLng(autreAdresse(0))
                    
                    If numero Mod 2 = 0 Then
                        If listePairs = "" Then
                            listePairs = CStr(numero)
                        Else
                            listePairs = listePairs & "," & CStr(numero)
                        End If
                    Else
                        If listeImpairs = "" Then
                            listeImpairs = CStr(numero)
                        Else
                            listeImpairs = listeImpairs & "," & CStr(numero)
                        End If
                    End If
                End If
            Next j
            
            ' Dénormaliser pour l'affichage
            Dim tourneeAff As String, secableAff As String, samediAff As String
            Dim cleParties As Variant
            cleParties = Split(cleSousGroupe, "§")
            tourneeAff = IIf(cleParties(0) = "VIDE", "", cleParties(0))
            secableAff = IIf(cleParties(1) = "VIDE", "", cleParties(1))
            samediAff = IIf(cleParties(2) = "VIDE", "", cleParties(2))
            
            ' Écrire les bornes
            If listePairs <> "" Then
                Dim bornePairs As String
                bornePairs = FormatBorne(listePairs)
                EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, bornePairs, _
                    libelleDistrict, tourneeAff, secableAff, samediAff
                resultRow = resultRow + 1
            End If
            
            If listeImpairs <> "" Then
                Dim borneImpairs As String
                borneImpairs = FormatBorne(listeImpairs)
                EcrireLigneResultat wsResult, resultRow, commune, motDirecteur, voie, ligne3, borneImpairs, _
                    libelleDistrict, tourneeAff, secableAff, samediAff
                resultRow = resultRow + 1
            End If
        End If
    Next i
End Sub

' Fonction pour formater une borne
Private Function FormatBorne(listeNumeros As String) As String
    If listeNumeros = "" Then
        FormatBorne = ""
        Exit Function
    End If
    
    Dim tabNumeros As Variant
    tabNumeros = Split(listeNumeros, ",")
    
    ' Convertir et trier
    Dim numArray() As Long
    ReDim numArray(0 To UBound(tabNumeros))
    
    Dim i As Long, j As Long, temp As Long
    For i = 0 To UBound(tabNumeros)
        numArray(i) = CLng(tabNumeros(i))
    Next i
    
    ' Tri
    For i = 0 To UBound(numArray) - 1
        For j = i + 1 To UBound(numArray)
            If numArray(i) > numArray(j) Then
                temp = numArray(i)
                numArray(i) = numArray(j)
                numArray(j) = temp
            End If
        Next j
    Next i
    
    ' Formater
    If UBound(numArray) = 0 Then
        FormatBorne = CStr(numArray(0))
    Else
        FormatBorne = CStr(numArray(0)) & " → " & CStr(numArray(UBound(numArray)))
    End If
End Function

' Subroutine pour écrire une ligne de résultat
Private Sub EcrireLigneResultat(ws As Worksheet, row As Long, _
    commune As String, motDirecteur As String, voie As String, _
    ligne3 As String, borne As String, libelleDistrict As String, _
    tournee As String, secable As String, samedi As String)
    
    With ws
        .Cells(row, 1).Value = commune
        .Cells(row, 2).Value = motDirecteur
        .Cells(row, 3).Value = voie
        .Cells(row, 4).Value = ligne3
        .Cells(row, 5).Value = borne
        .Cells(row, 6).Value = libelleDistrict
        .Cells(row, 7).Value = tournee
        .Cells(row, 8).Value = secable
        .Cells(row, 9).Value = samedi
    End With
End Sub
