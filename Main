Option Explicit

' --- Globals ---
Public g_wsSrc      As Worksheet
Public g_dataArr    As Variant
Public g_colComm    As Long
Public g_colVoie    As Long
Public g_colNum     As Long
Public g_colTour    As Long
Public g_colSecable As Long
Public g_colLigne   As Long
Public g_colLigne3  As Long
Public g_ligneCache As Object  ' Cache pour GetLigneText
Public g_ligne3Cache As Object ' Cache pour GetLigne3Text

' === UTILITAIRES OPTIMISÉS ===

Public Function GetLastWord(txt As Variant) As String
    Dim lastSpacePos As Long
    Dim strText As String
    
    On Error Resume Next
    strText = Trim(CStr(txt))
    If Len(strText) = 0 Then
        GetLastWord = ""
        Exit Function
    End If
    
    lastSpacePos = InStrRev(strText, " ")
    If lastSpacePos = 0 Then
        GetLastWord = strText
    Else
        GetLastWord = Mid(strText, lastSpacePos + 1)
    End If
End Function

' Fonction de tri optimisée avec QuickSort
Public Function QuickSortByLastWord(arr As Variant) As Variant
    Dim tmp As Variant
    tmp = arr
    If UBound(tmp) > 0 Then
        QuickSortRecursive tmp, 0, UBound(tmp)
    End If
    QuickSortByLastWord = tmp
End Function

Private Sub QuickSortRecursive(arr As Variant, ByVal low As Long, ByVal high As Long)
    Dim i As Long, j As Long, pivot As String, temp As Variant
    
    If low < high Then
        i = low
        j = high
        pivot = UCase$(GetLastWord(arr((low + high) \ 2)))
        
        Do While i <= j
            Do While UCase$(GetLastWord(arr(i))) < pivot And i < high
                i = i + 1
            Loop
            Do While pivot < UCase$(GetLastWord(arr(j))) And j > low
                j = j - 1
            Loop
            If i <= j Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
                i = i + 1
                j = j - 1
            End If
        Loop
        
        If low < j Then QuickSortRecursive arr, low, j
        If i < high Then QuickSortRecursive arr, i, high
    End If
End Sub

Public Function GetAbbreviatedRest(vName As Variant) As String
    Static abbrDict As Object
    Dim parts As Variant, firstWord As String
    Dim strName As String
    
    On Error Resume Next
    strName = Trim(CStr(vName))
    If Len(strName) = 0 Then
        GetAbbreviatedRest = ""
        Exit Function
    End If
    
    ' Initialiser le dictionnaire d'abréviations une seule fois
    If abbrDict Is Nothing Then
        Set abbrDict = CreateObject("Scripting.Dictionary")
        abbrDict("IMPASSE") = "IMP."
        abbrDict("ROUTE") = "RTE."
        abbrDict("AVENUE") = "AV."
        abbrDict("BOULEVARD") = "BD."
        abbrDict("CHEMIN") = "CH."
        abbrDict("ALLEE") = "ALL."
        abbrDict("PLACE") = "PL."
        abbrDict("SQUARE") = "SQ."
    End If
    
    parts = Split(strName, " ")
    If UBound(parts) < 0 Then
        GetAbbreviatedRest = strName
        Exit Function
    End If
    
    firstWord = UCase$(parts(0))
    If abbrDict.Exists(firstWord) Then
        parts(0) = abbrDict(firstWord)
    End If
    
    ' Reconstruire uniquement les n-1 premiers mots
    If UBound(parts) > 0 Then
        ReDim Preserve parts(0 To UBound(parts) - 1)
    End If
    
    GetAbbreviatedRest = Join(parts, " ")
End Function

' Fonctions optimisées avec cache
Public Function GetLigneText(ByVal cName As Variant, _
                             ByVal routeKey As Variant, _
                             ByVal tName As Variant) As String
    Dim cacheKey As String
    
    On Error Resume Next
    cacheKey = CStr(cName) & "|" & CStr(routeKey) & "|" & CStr(tName)
    
    If g_ligneCache.Exists(cacheKey) Then
        GetLigneText = g_ligneCache(cacheKey)
        Exit Function
    End If
    
    GetLigneText = ""
    g_ligneCache(cacheKey) = ""
End Function

Public Function GetLigne3Text(ByVal cName As Variant, _
                              ByVal routeKey As Variant, _
                              ByVal tName As Variant) As String
    Dim cacheKey As String
    
    On Error Resume Next
    cacheKey = CStr(cName) & "|" & CStr(routeKey) & "|" & CStr(tName)
    
    If g_ligne3Cache.Exists(cacheKey) Then
        GetLigne3Text = g_ligne3Cache(cacheKey)
        Exit Function
    End If
    
    GetLigne3Text = ""
    g_ligne3Cache(cacheKey) = ""
End Function

' === CHARGEMENT OPTIMISÉ DES DONNÉES ===

Public Function LoadTourneeData(ws As Worksheet) As Object
    Dim dictCom As Object, dictVoie As Object, dictTour As Object, numDict As Object
    Dim i As Long, cName As String, vName As Variant
    Dim secValue As Variant, secText As String
    Dim tNameRaw As String, tName As String
    Dim numKey As String
    Dim tournParts As Variant, tournNum As String
    Dim ligneText As String, ligne3Text As String
    Dim cacheKey As String

    Set g_wsSrc = ws
    g_dataArr = ws.UsedRange.Value
    
    ' Initialiser les caches
    Set g_ligneCache = CreateObject("Scripting.Dictionary")
    Set g_ligne3Cache = CreateObject("Scripting.Dictionary")

    ' Détection des colonnes
    For i = 1 To UBound(g_dataArr, 2)
        Select Case Trim(UCase$(g_dataArr(1, i)))
            Case "COMMUNE":   g_colComm = i
            Case "VOIE":      g_colVoie = i
            Case "NUMÉRO", "NUMERO": g_colNum = i
            Case "TOURNÉE", "TOURNEE": g_colTour = i
            Case "SÉCABLE", "SECABLE": g_colSecable = i
            Case "LIGNE":     g_colLigne = i
            Case "LIGNE 3":   g_colLigne3 = i
        End Select
    Next i
    
    If g_colComm * g_colVoie * g_colNum * g_colTour = 0 Then
        Err.Raise vbObjectError, , "Colonnes obligatoires introuvables"
    End If

    Set dictCom = CreateObject("Scripting.Dictionary")
    
    ' Premier passage : construction des dictionnaires et des caches
    For i = 2 To UBound(g_dataArr, 1)
        cName = CStr(g_dataArr(i, g_colComm))
        vName = g_dataArr(i, g_colVoie)
        numKey = CStr(g_dataArr(i, g_colNum))
        tNameRaw = CStr(g_dataArr(i, g_colTour))
        
        ' Gestion du sécable
        secValue = ""
        If g_colSecable > 0 Then
            secValue = Trim(CStr(g_dataArr(i, g_colSecable)))
        End If
        
        If Len(secValue) > 0 Then
            secText = "(" & secValue & ")"
            tName = tNameRaw & " " & secText
        Else
            tName = tNameRaw
        End If
        
        ' Construction du cache pour les lignes
        cacheKey = cName & "|" & CStr(vName) & "|" & tName
        
        ' Cache pour Ligne
        If g_colLigne > 0 And Not g_ligneCache.Exists(cacheKey) Then
            ligneText = Trim(CStr(g_dataArr(i, g_colLigne)))
            If Len(ligneText) > 0 Then
                g_ligneCache(cacheKey) = ligneText
            End If
        End If
        
        ' Cache pour Ligne 3
        If g_colLigne3 > 0 Then
            ligne3Text = Trim(CStr(g_dataArr(i, g_colLigne3)))
            If Len(ligne3Text) > 0 Then
                If g_ligne3Cache.Exists(cacheKey) Then
                    ' Ajouter à la liste existante si pas déjà présent
                    Dim existingTexts As String
                    existingTexts = g_ligne3Cache(cacheKey)
                    If InStr(existingTexts, ligne3Text) = 0 Then
                        g_ligne3Cache(cacheKey) = existingTexts & " - " & ligne3Text
                    End If
                Else
                    g_ligne3Cache(cacheKey) = ligne3Text
                End If
            End If
        End If
        
        ' Construction des dictionnaires
        If Not dictCom.Exists(cName) Then
            Set dictVoie = CreateObject("Scripting.Dictionary")
            dictCom.Add cName, dictVoie
        Else
            Set dictVoie = dictCom(cName)
        End If

        If Not dictVoie.Exists(vName) Then
            Set dictTour = CreateObject("Scripting.Dictionary")
            dictVoie.Add vName, dictTour
        Else
            Set dictTour = dictVoie(vName)
        End If

        If Not dictTour.Exists(tName) Then
            Set numDict = CreateObject("Scripting.Dictionary")
            numDict.Add numKey, True
            dictTour.Add tName, numDict
        Else
            If Not dictTour(tName).Exists(numKey) Then
                dictTour(tName).Add numKey, True
            End If
        End If
    Next i
    
    ' Finaliser le cache Ligne3 (ajouter les " -" à la fin)
    Dim key As Variant
    For Each key In g_ligne3Cache.Keys
        g_ligne3Cache(key) = g_ligne3Cache(key) & " -"
    Next

    Set LoadTourneeData = dictCom
End Function

' === GÉNÉRATION OPTIMISÉE ===

Public Sub GenerateIndicateurFlexible(dictCom As Object, wsOut As Worksheet, _
                                     nbColumns As Long, useToutSauf As Boolean)
    Dim cName As Variant, dictVoie As Object, dictTour As Object
    Dim dictAllTours As Object, countPerTour As Object
    Dim majorityTour As String, maxCount As Long, shouldUseToutSauf As Boolean
    Dim routeKey As Variant, tName As Variant, keyNum As Variant
    Dim currentRow As Long, prevLetter As String, currentLetter As String
    Dim oddMin As Long, oddMax As Long, evenMin As Long, evenMax As Long
    Dim oddPart As String, evenPart As String, bornes As String
    Dim fullVoie As String, lenLast As Long, ligneText As String, ligne3Text As String
    Dim lignes() As Variant, ligneCount As Long, info As Variant
    Dim idx As Long, r As Long, colOff As Long
    Dim n As Long, totalCols As Long, lastCol As String
    Dim sortedCommunes As Variant, sortedVoies As Variant
    Dim outputData() As Variant, outputRow As Long
    Dim numList() As Long, numCount As Long, j As Long
    
    ' Calcul du nombre total de colonnes
    totalCols = nbColumns * 2
    lastCol = Chr(64 + totalCols)
    
    ' Préallocation du tableau de sortie
    ReDim outputData(1 To 10000, 1 To totalCols)
    outputRow = 0
    
    ' Tri des communes une seule fois
    sortedCommunes = dictCom.Keys
    sortedCommunes = QuickSortByLastWord(sortedCommunes)
    
    For Each cName In sortedCommunes
        prevLetter = ""
        Set dictVoie = dictCom(cName)
        
        ' Déterminer toutes les tournées de la commune
        Set dictAllTours = CreateObject("Scripting.Dictionary")
        For Each routeKey In dictVoie.Keys
            For Each tName In dictVoie(routeKey).Keys
                dictAllTours(tName) = True
            Next
        Next
        
        ' Ajouter l'en-tête de commune
        outputRow = outputRow + 1
        If dictAllTours.Count = 1 Then
            outputData(outputRow, 1) = cName & " (" & dictAllTours.Keys()(0) & ")"
        Else
            shouldUseToutSauf = useToutSauf And (dictAllTours.Count <= 4)
            If shouldUseToutSauf Then
                ' Calcul rapide de la tournée majoritaire
                Set countPerTour = CreateObject("Scripting.Dictionary")
                For Each routeKey In dictVoie.Keys
                    Set dictTour = dictVoie(routeKey)
                    If dictTour.Count = 1 Then
                        tName = dictTour.Keys()(0)
                        countPerTour(tName) = countPerTour(tName) + 1
                    End If
                Next
                majorityTour = "": maxCount = 0
                For Each tName In countPerTour.Keys
                    If countPerTour(tName) > maxCount Then
                        maxCount = countPerTour(tName)
                        majorityTour = tName
                    End If
                Next
                outputData(outputRow, 1) = cName & " (" & majorityTour & ") sauf :"
            Else
                outputData(outputRow, 1) = cName
            End If
        End If
        
        ' Préparer la liste des lignes
        ReDim lignes(1 To 1000)
        ligneCount = 0
        
        ' Tri des voies
        sortedVoies = dictVoie.Keys
        sortedVoies = QuickSortByLastWord(sortedVoies)
        
        For Each routeKey In sortedVoies
            Set dictTour = dictVoie(routeKey)
            
            ' Filtrage pour mode "Tout sauf"
            If shouldUseToutSauf And dictTour.Count = 1 And dictTour.Exists(majorityTour) Then
                ' Ne pas inclure
            Else
                For Each tName In dictTour.Keys
                    ' Calcul optimisé des bornes
                    If dictTour.Count = 1 Then
                        bornes = ""
                    Else
                        ' Collecter tous les numéros en une seule passe
                        ReDim numList(1 To dictTour(tName).Count)
                        numCount = 0
                        For Each keyNum In dictTour(tName).Keys
                            If IsNumeric(keyNum) Then
                                numCount = numCount + 1
                                numList(numCount) = CLng(keyNum)
                            End If
                        Next
                        
                        If numCount > 0 Then
                            ' Tri rapide des numéros
                            For i = 1 To numCount - 1
                                For j = i + 1 To numCount
                                    If numList(i) > numList(j) Then
                                        n = numList(i)
                                        numList(i) = numList(j)
                                        numList(j) = n
                                    End If
                                Next
                            Next
                            
                            ' Calcul des bornes en une passe
                            oddMin = 999999: oddMax = -1
                            evenMin = 999999: evenMax = -1
                            For i = 1 To numCount
                                If numList(i) Mod 2 = 0 Then
                                    If numList(i) < evenMin Then evenMin = numList(i)
                                    If numList(i) > evenMax Then evenMax = numList(i)
                                Else
                                    If numList(i) < oddMin Then oddMin = numList(i)
                                    If numList(i) > oddMax Then oddMax = numList(i)
                                End If
                            Next
                            
                            ' Construction des bornes
                            oddPart = ""
                            If oddMin <= oddMax Then
                                If oddMin = oddMax Then
                                    oddPart = CStr(oddMin)
                                Else
                                    oddPart = CStr(oddMin) & " à " & CStr(oddMax)
                                End If
                            End If
                            
                            evenPart = ""
                            If evenMin <= evenMax Then
                                If evenMin = evenMax Then
                                    evenPart = CStr(evenMin)
                                Else
                                    evenPart = CStr(evenMin) & " à " & CStr(evenMax)
                                End If
                            End If
                            
                            If oddPart <> "" And evenPart <> "" Then
                                bornes = oddPart & " et " & evenPart
                            ElseIf oddPart <> "" Then
                                bornes = oddPart
                            Else
                                bornes = evenPart
                            End If
                        Else
                            bornes = ""
                        End If
                    End If
                    
                    ' Construction du texte de voie
                    lenLast = Len(GetLastWord(routeKey))
                    ligneText = GetLigneText(cName, routeKey, tName)
                    ligne3Text = GetLigne3Text(cName, routeKey, tName)
                    
                    fullVoie = UCase$(GetLastWord(routeKey)) & " (" & _
                               GetAbbreviatedRest(routeKey) & ")"
                    If ligne3Text <> "" Then fullVoie = fullVoie & " " & ligne3Text
                    If ligneText <> "" Then fullVoie = fullVoie & " " & ligneText
                    If bornes <> "" Then fullVoie = fullVoie & " " & bornes
                    
                    currentLetter = Left(UCase$(GetLastWord(routeKey)), 1)
                    
                    ligneCount = ligneCount + 1
                    lignes(ligneCount) = Array(fullVoie, tName, (dictTour.Count > 1), _
                                              (currentLetter <> prevLetter), lenLast)
                    prevLetter = currentLetter
                Next
            End If
        Next
        
        ' Écrire les lignes dans le tableau de sortie
        If nbColumns = 1 Then
            For idx = 1 To ligneCount
                outputRow = outputRow + 1
                outputData(outputRow, 1) = lignes(idx)(0)
                outputData(outputRow, 2) = lignes(idx)(1)
            Next
        Else
            For idx = 1 To ligneCount Step nbColumns
                outputRow = outputRow + 1
                For colOff = 0 To nbColumns - 1
                    If idx + colOff <= ligneCount Then
                        outputData(outputRow, 1 + 2 * colOff) = lignes(idx + colOff)(0)
                        outputData(outputRow, 1 + 2 * colOff + 1) = lignes(idx + colOff)(1)
                    End If
                Next
            Next
        End If
    Next
    
    ' Écrire tout le tableau en une seule fois
    If outputRow > 0 Then
        wsOut.Range("A1").Resize(outputRow, totalCols).Value = outputData
        
        ' Appliquer le formatage en une seule passe
        Application.ScreenUpdating = False
        
        ' Parcourir et formater
        currentRow = 1
        For Each cName In sortedCommunes
            ' Formater l'en-tête de commune
            With wsOut.Range("A" & currentRow & ":" & lastCol & currentRow)
                .Merge
                If InStr(.Value, "sauf") > 0 Then
                    .Interior.Color = vbBlue
                    .Font.Color = vbWhite
                ElseIf InStr(.Value, "(") > 0 And InStr(.Value, ")") > 0 Then
                    .Interior.Color = vbYellow
                Else
                    .Interior.Color = vbBlack
                    .Font.Color = vbWhite
                End If
                .Font.Bold = True
                .HorizontalAlignment = xlCenter
                .VerticalAlignment = xlCenter
            End With
            currentRow = currentRow + 1
            
            ' Le formatage détaillé des lignes peut être optimisé davantage si nécessaire
        Next
        
        Application.ScreenUpdating = True
    End If
End Sub

' === PROCÉDURE PRINCIPALE ===

Public Sub GenererIndicateurTournées()
    Dim nbColumns As Long, mode As Long
    Dim dictCom As Object
    Dim wsOut As Worksheet
    Dim useToutSauf As Boolean
    Dim i As Long

    ' Demander le nombre de colonnes
    nbColumns = Application.InputBox( _
        "Nombre de colonnes pour l'affichage ?" & vbCrLf & _
        "(1 = mode simple, 2+ = mode multi-colonnes)", _
        "Configuration de l'affichage", 1, Type:=1)
    
    If nbColumns < 1 Then
        MsgBox "Le nombre de colonnes doit être au moins 1.", vbExclamation
        Exit Sub
    End If

    ' Demander le mode d'affichage
    mode = Application.InputBox( _
        "Mode d'affichage :" & vbCrLf & _
        "1 = Standard (toutes les voies)" & vbCrLf & _
        "2 = Tout sauf (masquer les voies majoritaires)", _
        "Mode d'affichage", 1, Type:=1)
    
    If mode <> 1 And mode <> 2 Then
        MsgBox "Mode invalide.", vbExclamation
        Exit Sub
    End If
    
    useToutSauf = (mode = 2)

    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False

    ' Charger les données
    Set dictCom = LoadTourneeData(ActiveSheet)

    ' Créer la nouvelle feuille
    On Error Resume Next
    Application.DisplayAlerts = False
    Worksheets("indicateur de tg à vérifier").Delete
    Application.DisplayAlerts = True
    On Error GoTo 0

    Set wsOut = Worksheets.Add(After:=Sheets(Sheets.Count))
    wsOut.Name = "indicateur de tg à vérifier"

    ' Générer l'indicateur
    GenerateIndicateurFlexible dictCom, wsOut, nbColumns, useToutSauf

    ' Ajuster les largeurs de colonnes
    For i = 1 To nbColumns * 2
        wsOut.Columns(i).AutoFit
    Next i
    
    ' Centrer les colonnes de tournées
    For i = 2 To nbColumns * 2 Step 2
        wsOut.Columns(i).HorizontalAlignment = xlCenter
    Next i

    ' Ajouter les bordures
    wsOut.UsedRange.Borders.LineStyle = xlDash

    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True

    MsgBox "Indicateur généré avec " & nbColumns & " colonne(s) dans 'indicateur de tg à vérifier'.", vbInformation
End Sub
