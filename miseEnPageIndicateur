Sub MiseEnFormeParCommune()
    '=========================================================================
    ' MISE EN FORME DES DONNÉES PAR COMMUNE
    ' Regroupe les voies par commune et les affiche sur le nombre de colonnes choisi
    ' Format des voies : MOT_DIRECTEUR (reste de la voie) bornes
    '=========================================================================
    
    Dim wsSource As Worksheet
    Dim wsResultat As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim nbColonnes As Integer
    Dim ligneActuelle As Long
    Dim afficherSecable As Boolean
    Dim afficherSamedi As Boolean
    Dim nbChampsSupp As Integer
    
    ' 1. VÉRIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Set wsSource = Nothing
    On Error Resume Next
    Set wsSource = ThisWorkbook.Worksheets("Calcul des bornes")
    On Error GoTo 0
    
    If wsSource Is Nothing Then
        MsgBox "La feuille 'Calcul des bornes' n'existe pas !", vbCritical
        Exit Sub
    End If
    
    ' Vérifier qu'il y a des données
    lastRow = wsSource.Cells(wsSource.Rows.Count, 1).End(xlUp).row
    If lastRow < 2 Then
        MsgBox "Aucune donnée trouvée dans la feuille 'Calcul des bornes' !", vbCritical
        Exit Sub
    End If
    
    ' 2. DEMANDER LES OPTIONS D'AFFICHAGE
    '=========================================================================
    ' Demander si on affiche le champ Sécable
    Dim reponseSecable As VbMsgBoxResult
    reponseSecable = MsgBox("Voulez-vous afficher la colonne 'Sécable' ?", vbYesNo + vbQuestion, "Affichage Sécable")
    afficherSecable = (reponseSecable = vbYes)
    
    ' Demander si on affiche le champ Samedi
    Dim reponseSamedi As VbMsgBoxResult
    reponseSamedi = MsgBox("Voulez-vous afficher la colonne 'Samedi' ?", vbYesNo + vbQuestion, "Affichage Samedi")
    afficherSamedi = (reponseSamedi = vbYes)
    
    ' Calculer le nombre de champs supplémentaires
    nbChampsSupp = 0
    If afficherSecable Then nbChampsSupp = nbChampsSupp + 1
    If afficherSamedi Then nbChampsSupp = nbChampsSupp + 1
    
    ' 3. DEMANDER LE NOMBRE DE COLONNES
    '=========================================================================
    Do
        Dim reponse As String
        reponse = InputBox("Sur combien de colonnes souhaitez-vous afficher les voies ?" & vbCrLf & _
                          "Entrez un nombre entre 1 et 6 :", "Nombre de colonnes", "1")
        
        If reponse = "" Then Exit Sub ' Annulation
        
        If IsNumeric(reponse) Then
            nbColonnes = CInt(reponse)
            If nbColonnes >= 1 And nbColonnes <= 6 Then
                Exit Do
            Else
                MsgBox "Veuillez entrer un nombre entre 1 et 6.", vbExclamation
            End If
        Else
            MsgBox "Veuillez entrer un nombre valide.", vbExclamation
        End If
    Loop
    
    ' 4. CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Mise en forme par commune").Delete
    On Error GoTo 0
    Application.DisplayAlerts = True
    
    Set wsResultat = ThisWorkbook.Worksheets.Add
    wsResultat.Name = "Mise en forme par commune"
    
    ' 5. COLLECTE DES DONNÉES PAR COMMUNE
    '=========================================================================
    Dim dicCommunes As Object
    Set dicCommunes = CreateObject("Scripting.Dictionary")
    
    ' Parcourir toutes les lignes de données
    For i = 2 To lastRow
        Dim commune As String, voie As String, motDirecteur As String
        Dim borne As String, tournee As String, secable As String, samedi As String
        
        commune = Trim(CStr(wsSource.Cells(i, 1).value))
        motDirecteur = Trim(CStr(wsSource.Cells(i, 2).value))
        voie = Trim(CStr(wsSource.Cells(i, 3).value))
        borne = Trim(CStr(wsSource.Cells(i, 5).value))
        tournee = Trim(CStr(wsSource.Cells(i, 7).value))
        secable = Trim(CStr(wsSource.Cells(i, 8).value))
        samedi = Trim(CStr(wsSource.Cells(i, 9).value))
        
        If commune <> "" And voie <> "" Then
            ' Créer la clé formatée pour la voie avec le mot directeur
            Dim cleVoie As String
            cleVoie = FormatVoieAvecMotDirecteur(motDirecteur, voie, borne)
            
            ' Ajouter à la commune
            If Not dicCommunes.Exists(commune) Then
                Dim nouvelleCommune As Object
                Set nouvelleCommune = CreateObject("Scripting.Dictionary")
                dicCommunes.Add commune, nouvelleCommune
            End If
            
            ' Ajouter la voie avec ses propriétés
            If Not dicCommunes(commune).Exists(cleVoie) Then
                Dim proprietes As Object
                Set proprietes = CreateObject("Scripting.Dictionary")
                proprietes.Add "tournee", tournee
                proprietes.Add "secable", secable
                proprietes.Add "samedi", samedi
                dicCommunes(commune).Add cleVoie, proprietes
            End If
        End If
    Next i
    
    ' 6. AFFICHAGE DES DONNÉES TRIÉES
    '=========================================================================
    ligneActuelle = 1
    
    ' Créer les en-têtes selon le nombre de colonnes et les options
    Call CreerEntetes(wsResultat, nbColonnes, afficherSecable, afficherSamedi)
    ligneActuelle = 3 ' Commencer après les en-têtes
    
    ' Trier les communes alphabétiquement
    Dim communesTriees As Object
    Set communesTriees = TrierDictionnaire(dicCommunes)
    
    ' Parcourir chaque commune triée
    Dim cleCommune As Variant
    For Each cleCommune In communesTriees.keys
        Dim communeActuelle As String
        communeActuelle = CStr(cleCommune)
        
        ' Afficher le nom de la commune
        Call AfficherNomCommune(wsResultat, communeActuelle, ligneActuelle, nbColonnes, afficherSecable, afficherSamedi)
        ligneActuelle = ligneActuelle + 1
        
        ' Récupérer et trier les voies de cette commune
        Dim voiesCommune As Object
        Set voiesCommune = dicCommunes(cleCommune)
        
        Dim voiesTriees As Object
        Set voiesTriees = TrierDictionnaire(voiesCommune)
        
        ' Convertir en array (taille adaptée selon les options)
        Dim tailleArray As Integer
        tailleArray = 3 ' Voie + Tournée toujours présents
        If afficherSecable Then tailleArray = tailleArray + 1
        If afficherSamedi Then tailleArray = tailleArray + 1
        
        ReDim voiesArray(0 To voiesTriees.Count - 1, 0 To tailleArray - 1) As String
        Dim indexVoie As Long
        indexVoie = 0
        
        Dim cleVoieCommune As Variant
        For Each cleVoieCommune In voiesTriees.keys
            Dim propVoie As Object
            Set propVoie = voiesTriees(cleVoieCommune)
            
            Dim colIndex As Integer
            colIndex = 0
            
            voiesArray(indexVoie, colIndex) = CStr(cleVoieCommune) ' Voie
            colIndex = colIndex + 1
            voiesArray(indexVoie, colIndex) = propVoie("tournee") ' Tournée
            colIndex = colIndex + 1
            
            If afficherSecable Then
                voiesArray(indexVoie, colIndex) = propVoie("secable") ' Sécable
                colIndex = colIndex + 1
            End If
            
            If afficherSamedi Then
                voiesArray(indexVoie, colIndex) = propVoie("samedi") ' Samedi
            End If
            
            indexVoie = indexVoie + 1
        Next cleVoieCommune
        
        ' Afficher les voies
        Call AfficherVoiesReparties(wsResultat, voiesArray, voiesTriees.Count, ligneActuelle, nbColonnes, wsSource, afficherSecable, afficherSamedi)
        
        ' Calculer le nombre de lignes utilisées (sans ligne vide entre communes)
        Dim nbLignesVoies As Long
        nbLignesVoies = Application.WorksheetFunction.Ceiling_Precise(voiesTriees.Count / nbColonnes, 1)
        ligneActuelle = ligneActuelle + nbLignesVoies
    Next cleCommune
    
    ' 7. MISE EN FORME FINALE
    '=========================================================================
    Call AppliquerMiseEnForme(wsResultat, nbColonnes, afficherSecable, afficherSamedi)
    
    Dim champsAffiches As String
    champsAffiches = "Voie, Tournée"
    If afficherSecable Then champsAffiches = champsAffiches & ", Sécable"
    If afficherSamedi Then champsAffiches = champsAffiches & ", Samedi"
    
    MsgBox "Mise en forme terminée !" & vbCrLf & _
           "Communes traitées : " & communesTriees.Count & vbCrLf & _
           "Affichage sur " & nbColonnes & " colonne(s)" & vbCrLf & _
           "Champs affichés : " & champsAffiches, vbInformation
End Sub

Function TrierDictionnaire(ByRef dicOriginal As Object) As Object
    '=========================================================================
    ' TRIE UN DICTIONNAIRE PAR ORDRE ALPHABÉTIQUE DES CLÉS
    '=========================================================================
    Dim dicTrie As Object
    Set dicTrie = CreateObject("Scripting.Dictionary")
    
    ' Convertir les clés en array pour les trier
    Dim cles As Variant
    cles = dicOriginal.keys
    
    ' Tri à bulles des clés
    Dim i As Long, j As Long
    Dim temp As Variant
    
    For i = LBound(cles) To UBound(cles) - 1
        For j = LBound(cles) To UBound(cles) - 1
            If UCase(CStr(cles(j))) > UCase(CStr(cles(j + 1))) Then
                temp = cles(j)
                cles(j) = cles(j + 1)
                cles(j + 1) = temp
            End If
        Next j
    Next i
    
    ' Reconstruire le dictionnaire trié
    For i = LBound(cles) To UBound(cles)
        dicTrie.Add cles(i), dicOriginal(cles(i))
    Next i
    
    Set TrierDictionnaire = dicTrie
End Function

Function FormatVoieAvecMotDirecteur(ByVal motDirecteur As String, ByVal voie As String, ByVal borne As String) As String
    '=========================================================================
    ' FORMATAGE DU NOM DE VOIE AVEC MOT DIRECTEUR
    ' Format : MOTDIRECTEUR (reste de la voie) bornes
    ' Évite la répétition du mot directeur dans les parenthèses
    '=========================================================================
    Dim voieFormatee As String
    Dim resteVoie As String
    
    ' Nettoyer et normaliser les chaînes
    Dim motDirecteurClean As String
    Dim voieClean As String
    motDirecteurClean = UCase(Trim(CStr(motDirecteur)))
    voieClean = UCase(Trim(CStr(voie)))
    
    ' Commencer avec la voie complète
    resteVoie = Trim(CStr(voie))
    
    ' Stratégie 1: Le mot directeur est au début de la voie
    If InStr(1, voieClean, motDirecteurClean) = 1 Then
        resteVoie = Trim(Mid(resteVoie, Len(motDirecteurClean) + 1))
    End If
    
    ' Stratégie 2: Le mot directeur est à la fin de la voie (comme "ROUTE DU PIC")
    If Right(voieClean, Len(motDirecteurClean)) = motDirecteurClean Then
        ' Vérifier qu'il y a un espace ou préposition avant
        Dim positionFin As Integer
        positionFin = Len(voieClean) - Len(motDirecteurClean) + 1
        If positionFin > 1 Then
            Dim caracterePrecedent As String
            caracterePrecedent = Mid(voieClean, positionFin - 1, 1)
            If caracterePrecedent = " " Then
                ' Enlever le mot directeur de la fin
                resteVoie = Trim(Left(resteVoie, Len(resteVoie) - Len(motDirecteurClean)))
            End If
        End If
    End If
    
    ' Stratégie 3: Le mot directeur est au milieu (avec des prépositions)
    Dim patterns As Variant
    patterns = Array(" DU " & motDirecteurClean, " DE " & motDirecteurClean, " DES " & motDirecteurClean, _
                    " DE LA " & motDirecteurClean, " DE L'" & motDirecteurClean)
    
    Dim i As Integer
    For i = 0 To UBound(patterns)
        If InStr(voieClean, patterns(i)) > 0 Then
            resteVoie = Replace(resteVoie, patterns(i), "", 1, 1, vbTextCompare)
            resteVoie = Trim(resteVoie)
            Exit For
        End If
    Next i
    
    ' Nettoyer les prépositions orphelines au début ou à la fin
    resteVoie = Trim(resteVoie)
    
    ' Enlever prépositions au début
    If Left(UCase(resteVoie), 3) = "DE " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 3) = "DU " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 4) = "DES " Then
        resteVoie = Trim(Mid(resteVoie, 5))
    ElseIf Left(UCase(resteVoie), 3) = "LA " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 3) = "LE " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 4) = "LES " Then
        resteVoie = Trim(Mid(resteVoie, 5))
    End If
    
    ' Enlever prépositions à la fin
    If Right(UCase(resteVoie), 3) = " DE" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 3))
    ElseIf Right(UCase(resteVoie), 3) = " DU" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 3))
    ElseIf Right(UCase(resteVoie), 4) = " DES" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 4))
    End If
    
    ' Construire le format final
    If resteVoie <> "" And UCase(resteVoie) <> motDirecteurClean And Len(resteVoie) > 1 Then
        voieFormatee = motDirecteurClean & " (" & resteVoie & ")"
    Else
        voieFormatee = motDirecteurClean
    End If
    
    ' Ajouter les bornes si présentes
    If borne <> "" Then
        voieFormatee = voieFormatee & " " & borne
    End If
    
    FormatVoieAvecMotDirecteur = voieFormatee
End Function

Sub CreerEntetes(ByRef ws As Worksheet, ByVal nbColonnes As Integer, ByVal afficherSecable As Boolean, ByVal afficherSamedi As Boolean)
    '=========================================================================
    ' CRÉATION DES EN-TÊTES SELON LES OPTIONS
    '=========================================================================
    Dim col As Integer
    Dim nbChampsParColonne As Integer
    
    ' Calculer le nombre de champs par colonne
    nbChampsParColonne = 2 ' Voie + Tournée toujours présents
    If afficherSecable Then nbChampsParColonne = nbChampsParColonne + 1
    If afficherSamedi Then nbChampsParColonne = nbChampsParColonne + 1
    
    For col = 1 To nbColonnes
        Dim colBase As Integer
        colBase = (col - 1) * nbChampsParColonne + 1
        
        Dim colIndex As Integer
        colIndex = colBase
        
        ws.Cells(1, colIndex) = "Voie"
        colIndex = colIndex + 1
        ws.Cells(1, colIndex) = "Tournée"
        colIndex = colIndex + 1
        
        If afficherSecable Then
            ws.Cells(1, colIndex) = "Sécable"
            colIndex = colIndex + 1
        End If
        
        If afficherSamedi Then
            ws.Cells(1, colIndex) = "Samedi"
        End If
        
        ' Mise en forme des en-têtes
        With ws.Range(ws.Cells(1, colBase), ws.Cells(1, colBase + nbChampsParColonne - 1))
            .Font.Bold = True
            .Interior.Color = RGB(180, 198, 231)
            .HorizontalAlignment = xlCenter
        End With
    Next col
End Sub

Sub AfficherNomCommune(ByRef ws As Worksheet, ByVal commune As String, ByVal ligne As Long, ByVal nbColonnes As Integer, ByVal afficherSecable As Boolean, ByVal afficherSamedi As Boolean)
    '=========================================================================
    ' AFFICHAGE DU NOM DE LA COMMUNE
    '=========================================================================
    Dim nbChampsParColonne As Integer
    nbChampsParColonne = 2 ' Voie + Tournée
    If afficherSecable Then nbChampsParColonne = nbChampsParColonne + 1
    If afficherSamedi Then nbChampsParColonne = nbChampsParColonne + 1
    
    Dim dernierCol As Integer
    dernierCol = nbColonnes * nbChampsParColonne
    
    ' Fusionner les cellules et écrire le nom de la commune
    With ws.Range(ws.Cells(ligne, 1), ws.Cells(ligne, dernierCol))
        .Merge
        .value = UCase(commune)
        .Font.Bold = True
        .Font.Size = 12
        .Interior.Color = RGB(255, 255, 0) ' Jaune
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlMedium
    End With
End Sub

Sub AfficherVoiesReparties(ByRef ws As Worksheet, ByRef voiesArray As Variant, ByVal nbVoies As Long, _
                          ByRef ligneDebut As Long, ByVal nbColonnes As Integer, ByRef wsSource As Worksheet, _
                          ByVal afficherSecable As Boolean, ByVal afficherSamedi As Boolean)
    '=========================================================================
    ' AFFICHAGE DES VOIES RÉPARTIES SUR LES COLONNES
    ' Avec adaptation selon les options d'affichage
    '=========================================================================
    Dim voieIndex As Long
    Dim ligne As Long, col As Integer
    Dim maxLignes As Long
    Dim lettreActuelle As String
    Dim lettrePrecedente As String
    Dim nbChampsParColonne As Integer
    
    ' Calculer le nombre de champs par colonne
    nbChampsParColonne = 2 ' Voie + Tournée
    If afficherSecable Then nbChampsParColonne = nbChampsParColonne + 1
    If afficherSamedi Then nbChampsParColonne = nbChampsParColonne + 1
    
    lettrePrecedente = ""
    
    ' Calculer le nombre maximum de lignes nécessaires
    maxLignes = Application.WorksheetFunction.Ceiling_Precise(nbVoies / nbColonnes, 1)
    
    voieIndex = 0
    
    For ligne = 0 To maxLignes - 1
        For col = 1 To nbColonnes
            If voieIndex < nbVoies Then
                Dim colBase As Integer
                colBase = (col - 1) * nbChampsParColonne + 1
                Dim ligneActuelle As Long
                ligneActuelle = ligneDebut + ligne
                
                ' Extraire le mot directeur de la voie
                Dim voieComplete As String
                voieComplete = CStr(voiesArray(voieIndex, 0))
                Dim motDirecteur As String
                motDirecteur = ExtraireMotDirecteur(voieComplete)
                
                ' Détecter changement de première lettre
                lettreActuelle = UCase(Left(motDirecteur, 1))
                Dim changementLettre As Boolean
                changementLettre = (lettreActuelle <> lettrePrecedente And lettrePrecedente <> "")
                
                ' Formater la voie avec indicateur de changement de lettre (flèche vers la droite)
                Dim voieFormatee As String
                If changementLettre Then
                    voieFormatee = ">> " & voieComplete ' Flèche vers la droite pour le changement
                Else
                    voieFormatee = voieComplete
                End If
                
                ' Écrire les données selon les options
                Dim colIndex As Integer
                colIndex = colBase
                
                ws.Cells(ligneActuelle, colIndex) = voieFormatee ' Voie
                colIndex = colIndex + 1
                ws.Cells(ligneActuelle, colIndex) = voiesArray(voieIndex, 1) ' Tournée
                colIndex = colIndex + 1
                
                If afficherSecable Then
                    ws.Cells(ligneActuelle, colIndex) = voiesArray(voieIndex, 2) ' Sécable
                    colIndex = colIndex + 1
                End If
                
                If afficherSamedi Then
                    Dim indexSamedi As Integer
                    If afficherSecable Then
                        indexSamedi = 3
                    Else
                        indexSamedi = 2
                    End If
                    ws.Cells(ligneActuelle, colIndex) = voiesArray(voieIndex, indexSamedi) ' Samedi
                End If
                
                ' Mise en forme du mot directeur en gras
                Call MettreMotDirecteurEnGras(ws.Cells(ligneActuelle, colBase), motDirecteur)
                
                ' Vérifier s'il y a des numéros (bornes) dans la voie
                Dim aDesNumeros As Boolean
                aDesNumeros = VoieContientDesNumeros(voieComplete)
                
                ' Mise en forme des cellules avec alignement et bordures spéciales
                With ws.Range(ws.Cells(ligneActuelle, colBase), ws.Cells(ligneActuelle, colBase + nbChampsParColonne - 1))
                    ' Bordures latérales continues
                    .Borders(xlEdgeLeft).LineStyle = xlContinuous
                    .Borders(xlEdgeRight).LineStyle = xlContinuous
                    .Borders(xlInsideVertical).LineStyle = xlContinuous
                    
                    ' Bordures supérieure et inférieure en pointillés
                    .Borders(xlEdgeTop).LineStyle = xlDot
                    .Borders(xlEdgeBottom).LineStyle = xlDot
                    
                    .VerticalAlignment = xlCenter
                End With
                
                ' Mise en forme spécifique pour la colonne Voie
                With ws.Cells(ligneActuelle, colBase)
                    .HorizontalAlignment = xlLeft ' Voie à gauche
                    .IndentLevel = 1 ' Léger décalage pour aérer l'affichage
                    
                    ' Fond vert et police blanche si la voie contient des numéros
                    If aDesNumeros Then
                        .Interior.Color = RGB(144, 238, 144) ' Vert clair
                        .Font.Color = RGB(255, 255, 255) ' Police blanche
                    Else
                        .Interior.Color = xlNone ' Pas de couleur de fond
                        .Font.Color = RGB(0, 0, 0) ' Police noire par défaut
                    End If
                End With
                
                ' Mise en forme pour la colonne Tournée (noir)
                With ws.Cells(ligneActuelle, colBase + 1)
                    .HorizontalAlignment = xlCenter ' Tournée centrée
                    .Font.Color = RGB(0, 0, 0) ' Police noire
                    .Interior.Color = RGB(220, 230, 241) ' Fond bleu clair
                End With
                
                ' Mise en forme pour les colonnes supplémentaires
                Dim colIndexFormat As Integer
                colIndexFormat = colBase + 2
                
                If afficherSecable Then
                    With ws.Cells(ligneActuelle, colIndexFormat)
                        .HorizontalAlignment = xlCenter ' Sécable centrée
                        .Font.Color = RGB(0, 0, 255) ' Police bleue
                        .Interior.Color = xlNone ' Pas de couleur de fond
                    End With
                    colIndexFormat = colIndexFormat + 1
                End If
                
                If afficherSamedi Then
                    With ws.Cells(ligneActuelle, colIndexFormat)
                        .HorizontalAlignment = xlCenter ' Samedi centrée
                        .Font.Color = RGB(255, 0, 0) ' Police rouge
                        .Interior.Color = xlNone ' Pas de couleur de fond
                    End With
                End If
                
                lettrePrecedente = lettreActuelle
                voieIndex = voieIndex + 1
            End If
        Next col
    Next ligne
End Sub

Function ExtraireMotDirecteur(ByVal voieComplete As String) As String
    '=========================================================================
    ' EXTRAIT LE MOT DIRECTEUR D'UNE VOIE FORMATÉE
    ' Ex: "PIC (ROUTE) 25" → "PIC"
    '=========================================================================
    Dim posParenthese As Integer
    posParenthese = InStr(voieComplete, " (")
    
    If posParenthese > 0 Then
        ExtraireMotDirecteur = Trim(Left(voieComplete, posParenthese - 1))
    Else
        ' Si pas de parenthèses, prendre le premier mot
        Dim mots As Variant
        mots = Split(Trim(voieComplete), " ")
        If UBound(mots) >= 0 Then
            ExtraireMotDirecteur = Trim(mots(0))
        Else
            ExtraireMotDirecteur = Trim(voieComplete)
        End If
    End If
    
    ' Enlever la flèche si elle est présente
    If Left(ExtraireMotDirecteur, 3) = ">> " Then
        ExtraireMotDirecteur = Trim(Mid(ExtraireMotDirecteur, 4))
    End If
End Function

Sub MettreMotDirecteurEnGras(ByRef cellule As Range, ByVal motDirecteur As String)
    '=========================================================================
    ' MET LE MOT DIRECTEUR EN GRAS DANS LA CELLULE
    '=========================================================================
    Dim texteComplet As String
    Dim positionDebut As Integer
    Dim longueurMot As Integer
    
    texteComplet = cellule.value
    
    ' Chercher la position du mot directeur dans le texte
    positionDebut = InStr(1, texteComplet, motDirecteur, vbTextCompare)
    
    If positionDebut > 0 Then
        longueurMot = Len(motDirecteur)
        
        ' Mettre en gras seulement le mot directeur
        With cellule.Characters(positionDebut, longueurMot).Font
            .Bold = True
            .Size = cellule.Font.Size ' Garder la même taille
        End With
    End If
End Sub

Function VoieContientDesNumeros(ByVal voie As String) As Boolean
    '=========================================================================
    ' VÉRIFIE SI UNE VOIE CONTIENT DES NUMÉROS (BORNES)
    ' Recherche des patterns comme "1 à 25", "185 à 295", ou numéros isolés
    '=========================================================================
    
    VoieContientDesNumeros = False
    
    ' Chercher des patterns de plages de numéros
    If InStr(voie, " à ") > 0 Or _
       InStr(voie, " / ") > 0 Or _
       InStr(voie, "à") > 0 Or _
       InStr(voie, "/") > 0 Then
        
        ' Vérifier qu'il y a des chiffres
        Dim i As Integer
        For i = 1 To Len(voie)
            If IsNumeric(Mid(voie, i, 1)) Then
                VoieContientDesNumeros = True
                Exit Function
            End If
        Next i
    End If
    
    ' Chercher des numéros isolés (après un espace à la fin)
    Dim mots As Variant
    mots = Split(Trim(voie), " ")
    If UBound(mots) >= 0 Then
        Dim dernierMot As String
        dernierMot = Trim(mots(UBound(mots)))
        
        ' Vérifier si le dernier mot est un nombre
        If IsNumeric(dernierMot) And Len(dernierMot) > 0 Then
            VoieContientDesNumeros = True
            Exit Function
        End If
        
        ' Vérifier si le dernier mot contient des chiffres et ressemble à une borne
        If Len(dernierMot) > 0 Then
            Dim contientChiffre As Boolean
            contientChiffre = False
            For i = 1 To Len(dernierMot)
                If IsNumeric(Mid(dernierMot, i, 1)) Then
                    contientChiffre = True
                    Exit For
                End If
            Next i
            
            ' Si contient des chiffres et des caractères de borne
            If contientChiffre And (InStr(dernierMot, "à") > 0 Or InStr(dernierMot, "/") > 0 Or InStr(dernierMot, "-") > 0) Then
                VoieContientDesNumeros = True
                Exit Function
            End If
        End If
    End If
    
    ' Chercher n'importe quel groupe de chiffres dans la chaîne (pour les cas comme TM0001 25)
    Dim j As Integer
    Dim numeroEnCours As String
    numeroEnCours = ""
    
    For j = 1 To Len(voie)
        Dim char As String
        char = Mid(voie, j, 1)
        
        If IsNumeric(char) Then
            numeroEnCours = numeroEnCours & char
        Else
            ' Si on a trouvé un nombre et qu'on arrive à un non-chiffre
            If Len(numeroEnCours) > 0 Then
                ' Vérifier si c'est un vrai numéro de voie (pas juste dans le code tournée)
                If Len(numeroEnCours) <= 3 And j > Len(voie) - 10 Then ' Numéro court en fin de chaîne
                    VoieContientDesNumeros = True
                    Exit Function
                End If
                numeroEnCours = ""
            End If
        End If
    Next j
    
    ' Vérifier le dernier numéro si la chaîne se termine par un chiffre
    If Len(numeroEnCours) > 0 And Len(numeroEnCours) <= 3 Then
        VoieContientDesNumeros = True
    End If
End Function

Sub AppliquerMiseEnForme(ByRef ws As Worksheet, ByVal nbColonnes As Integer, ByVal afficherSecable As Boolean, ByVal afficherSamedi As Boolean)
    '=========================================================================
    ' MISE EN FORME FINALE SELON LES OPTIONS
    '=========================================================================
    
    Dim nbChampsParColonne As Integer
    nbChampsParColonne = 2 ' Voie + Tournée
    If afficherSecable Then nbChampsParColonne = nbChampsParColonne + 1
    If afficherSamedi Then nbChampsParColonne = nbChampsParColonne + 1
    
    ' Ajuster automatiquement les colonnes de voies, forcer les autres en pixels
    Dim col As Integer
    For col = 1 To nbColonnes * nbChampsParColonne
        Dim colType As Integer
        colType = ((col - 1) Mod nbChampsParColonne) + 1
        
        Select Case colType
            Case 1 ' Voie - AutoFit avec minimum
                ws.Columns(col).AutoFit
                If ws.Columns(col).ColumnWidth < 25 Then
                    ws.Columns(col).ColumnWidth = 25
                End If
            Case 2 ' Tournée - Largeur forcée à 40 pixels
                ws.Columns(col).ColumnWidth = 5.43 ' Approximativement 40 pixels
            Case Else ' Sécable ou Samedi - Largeur forcée à 40 pixels
                ws.Columns(col).ColumnWidth = 5.43 ' Approximativement 40 pixels
        End Select
    Next col
    
    ' Centrer horizontalement les en-têtes des colonnes Tournée, Sécable et Samedi
    For col = 1 To nbColonnes
        Dim colBase As Integer
        colBase = (col - 1) * nbChampsParColonne + 1
        
        ' Tournée (toujours colBase + 1)
        ws.Cells(1, colBase + 1).HorizontalAlignment = xlCenter
        
        Dim colIndexHeader As Integer
        colIndexHeader = colBase + 2
        If afficherSecable Then
            ws.Cells(1, colIndexHeader).HorizontalAlignment = xlCenter ' En-tête Sécable
            colIndexHeader = colIndexHeader + 1
        End If
        
        If afficherSamedi Then
            ws.Cells(1, colIndexHeader).HorizontalAlignment = xlCenter ' En-tête Samedi
        End If
    Next col
    
    ' Figer la première ligne
    ws.Rows("2:2").Select
    ActiveWindow.FreezePanes = True
    
    ' Sélectionner la cellule A1
    ws.Range("A1").Select
End Sub
