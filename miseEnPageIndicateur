Sub MiseEnFormeParCommune()
    '=========================================================================
    ' MISE EN FORME DES DONNÉES PAR COMMUNE
    ' Regroupe les voies par commune et les affiche sur le nombre de colonnes choisi
    ' Format des voies : MOT_DIRECTEUR (reste de la voie) bornes
    '=========================================================================
    
    Dim wsSource As Worksheet
    Dim wsResultat As Worksheet
    Dim lastRow As Long
    Dim i As Long
    Dim nbColonnes As Integer
    Dim ligneActuelle As Long
    
    ' 1. VÉRIFICATION DE LA FEUILLE SOURCE
    '=========================================================================
    Set wsSource = Nothing
    On Error Resume Next
    Set wsSource = ThisWorkbook.Worksheets("Calcul des bornes")
    On Error GoTo 0
    
    If wsSource Is Nothing Then
        MsgBox "La feuille 'Calcul des bornes' n'existe pas !", vbCritical
        Exit Sub
    End If
    
    ' Vérifier qu'il y a des données
    lastRow = wsSource.Cells(wsSource.Rows.Count, 1).End(xlUp).Row
    If lastRow < 2 Then
        MsgBox "Aucune donnée trouvée dans la feuille 'Calcul des bornes' !", vbCritical
        Exit Sub
    End If
    
    ' 2. DEMANDER LE NOMBRE DE COLONNES
    '=========================================================================
    Do
        Dim reponse As String
        reponse = InputBox("Sur combien de colonnes souhaitez-vous afficher les voies ?" & vbCrLf & _
                          "Entrez un nombre entre 1 et 6 :", "Nombre de colonnes", "1")
        
        If reponse = "" Then Exit Sub ' Annulation
        
        If IsNumeric(reponse) Then
            nbColonnes = CInt(reponse)
            If nbColonnes >= 1 And nbColonnes <= 6 Then
                Exit Do
            Else
                MsgBox "Veuillez entrer un nombre entre 1 et 6.", vbExclamation
            End If
        Else
            MsgBox "Veuillez entrer un nombre valide.", vbExclamation
        End If
    Loop
    
    ' 3. CRÉATION DE LA FEUILLE RÉSULTAT
    '=========================================================================
    Application.DisplayAlerts = False
    On Error Resume Next
    ThisWorkbook.Worksheets("Mise en forme par commune").Delete
    On Error GoTo 0
    Application.DisplayAlerts = True
    
    Set wsResultat = ThisWorkbook.Worksheets.Add
    wsResultat.Name = "Mise en forme par commune"
    
    ' 4. COLLECTE DES DONNÉES PAR COMMUNE
    '=========================================================================
    Dim dicCommunes As Object
    Set dicCommunes = CreateObject("Scripting.Dictionary")
    
    ' Parcourir toutes les lignes de données
    For i = 2 To lastRow
        Dim commune As String, voie As String, motDirecteur As String
        Dim borne As String, tournee As String, secable As String, samedi As String
        
        commune = Trim(CStr(wsSource.Cells(i, 1).Value))
        motDirecteur = Trim(CStr(wsSource.Cells(i, 2).Value))
        voie = Trim(CStr(wsSource.Cells(i, 3).Value))
        borne = Trim(CStr(wsSource.Cells(i, 5).Value))
        tournee = Trim(CStr(wsSource.Cells(i, 7).Value))
        secable = Trim(CStr(wsSource.Cells(i, 8).Value))
        samedi = Trim(CStr(wsSource.Cells(i, 9).Value))
        
        If commune <> "" And voie <> "" Then
            ' Créer la clé formatée pour la voie avec le mot directeur
            Dim cleVoie As String
            cleVoie = FormatVoieAvecMotDirecteur(motDirecteur, voie, borne)
            
            ' Ajouter à la commune
            If Not dicCommunes.Exists(commune) Then
                Dim nouvelleCommune As Object
                Set nouvelleCommune = CreateObject("Scripting.Dictionary")
                dicCommunes.Add commune, nouvelleCommune
            End If
            
            ' Ajouter la voie avec ses propriétés
            If Not dicCommunes(commune).Exists(cleVoie) Then
                Dim proprietes As Object
                Set proprietes = CreateObject("Scripting.Dictionary")
                proprietes.Add "tournee", tournee
                proprietes.Add "secable", secable
                proprietes.Add "samedi", samedi
                dicCommunes(commune).Add cleVoie, proprietes
            End If
        End If
    Next i
    
    ' 5. AFFICHAGE DES DONNÉES (TRIÉES)
    '=========================================================================
    ligneActuelle = 1
    
    ' Créer les en-têtes selon le nombre de colonnes
    Call CreerEntetes(wsResultat, nbColonnes)
    ligneActuelle = 3 ' Commencer après les en-têtes
    
    ' Trier les communes alphabétiquement
    Dim communesTriees As Object
    Set communesTriees = TrierDictionnaire(dicCommunes)
    
    ' Parcourir chaque commune (triée)
    Dim cleCommune As Variant
    For Each cleCommune In communesTriees.Keys
        Dim communeActuelle As String
        communeActuelle = CStr(cleCommune)
        
        ' Afficher le nom de la commune (fusionné sur toutes les colonnes)
        Call AfficherNomCommune(wsResultat, communeActuelle, ligneActuelle, nbColonnes)
        ligneActuelle = ligneActuelle + 1
        
        ' Récupérer et trier les voies de cette commune
        Dim voiesCommune As Object
        Set voiesCommune = dicCommunes(cleCommune)
        
        Dim voiesTriees As Object
        Set voiesTriees = TrierDictionnaire(voiesCommune)
        
        ' Convertir en array pour pouvoir les répartir
        ReDim voiesArray(0 To voiesTriees.Count - 1, 0 To 3) As String
        Dim indexVoie As Long
        indexVoie = 0
        
        Dim cleVoieCommune As Variant
        For Each cleVoieCommune In voiesTriees.Keys
            Dim propVoie As Object
            Set propVoie = voiesTriees(cleVoieCommune)
            
            voiesArray(indexVoie, 0) = CStr(cleVoieCommune)
            voiesArray(indexVoie, 1) = propVoie("tournee")
            voiesArray(indexVoie, 2) = propVoie("secable")
            voiesArray(indexVoie, 3) = propVoie("samedi")
            indexVoie = indexVoie + 1
        Next cleVoieCommune
        
        ' Afficher les voies réparties sur les colonnes
        Call AfficherVoiesReparties(wsResultat, voiesArray, voiesTriees.Count, ligneActuelle, nbColonnes, wsSource)
        
        ' Calculer le nombre de lignes utilisées
        Dim nbLignesVoies As Long
        nbLignesVoies = Application.WorksheetFunction.Ceiling_Precise(voiesTriees.Count / nbColonnes, 1)
        ligneActuelle = ligneActuelle + nbLignesVoies + 1 ' +1 pour l'espacement
    Next cleCommuneeActuelle = CStr(cleCommune)
        
        ' Afficher le nom de la commune (fusionné sur toutes les colonnes)
        Call AfficherNomCommune(wsResultat, communeActuelle, ligneActuelle, nbColonnes)
        ligneActuelle = ligneActuelle + 1
        
        ' Récupérer toutes les voies de cette commune
        Dim voiesCommune As Object
        Set voiesCommune = dicCommunes(cleCommune)
        
        ' Convertir en array pour pouvoir les répartir
        ReDim voiesArray(0 To voiesCommune.Count - 1, 0 To 3) As String
        Dim indexVoie As Long
        indexVoie = 0
        
        Dim cleVoieCommune As Variant
        For Each cleVoieCommune In voiesCommune.Keys
            Dim propVoie As Object
            Set propVoie = voiesCommune(cleVoieCommune)
            
            voiesArray(indexVoie, 0) = CStr(cleVoieCommune)
            voiesArray(indexVoie, 1) = propVoie("tournee")
            voiesArray(indexVoie, 2) = propVoie("secable")
            voiesArray(indexVoie, 3) = propVoie("samedi")
            indexVoie = indexVoie + 1
        Next cleVoieCommune
        
        ' Afficher les voies réparties sur les colonnes
        Call AfficherVoiesReparties(wsResultat, voiesArray, voiesCommune.Count, ligneActuelle, nbColonnes, wsSource)
        
        ' Calculer le nombre de lignes utilisées
        Dim nbLignesVoies As Long
        nbLignesVoies = Application.WorksheetFunction.Ceiling_Precise(voiesCommune.Count / nbColonnes, 1)
        ligneActuelle = ligneActuelle + nbLignesVoies + 1 ' +1 pour l'espacement
    Next cleCommune
    
    ' 6. MISE EN FORME FINALE
    '=========================================================================
    Call AppliquerMiseEnForme(wsResultat, nbColonnes)
    
    MsgBox "Mise en forme terminée !" & vbCrLf & _
           "Communes traitées : " & communesTriees.Count & vbCrLf & _
           "Affichage sur " & nbColonnes & " colonne(s)", vbInformation
End Sub

Function TrierDictionnaire(ByRef dicOriginal As Object) As Object
    '=========================================================================
    ' TRIE UN DICTIONNAIRE PAR ORDRE ALPHABÉTIQUE DES CLÉS
    '=========================================================================
    Dim dicTrie As Object
    Set dicTrie = CreateObject("Scripting.Dictionary")
    
    ' Convertir les clés en array pour les trier
    Dim cles As Variant
    cles = dicOriginal.Keys
    
    ' Tri à bulles des clés
    Dim i As Long, j As Long
    Dim temp As Variant
    
    For i = LBound(cles) To UBound(cles) - 1
        For j = LBound(cles) To UBound(cles) - 1
            If UCase(CStr(cles(j))) > UCase(CStr(cles(j + 1))) Then
                temp = cles(j)
                cles(j) = cles(j + 1)
                cles(j + 1) = temp
            End If
        Next j
    Next i
    
    ' Reconstruire le dictionnaire trié
    For i = LBound(cles) To UBound(cles)
        dicTrie.Add cles(i), dicOriginal(cles(i))
    Next i
    
    Set TrierDictionnaire = dicTrie
End Function

Function FormatVoieAvecMotDirecteur(ByVal motDirecteur As String, ByVal voie As String, ByVal borne As String) As String
    '=========================================================================
    ' FORMATAGE DU NOM DE VOIE AVEC MOT DIRECTEUR
    ' Format : MOTDIRECTEUR (reste de la voie) bornes
    ' Évite la répétition du mot directeur dans les parenthèses
    '=========================================================================
    Dim voieFormatee As String
    Dim resteVoie As String
    
    ' Nettoyer et normaliser les chaînes
    Dim motDirecteurClean As String
    Dim voieClean As String
    motDirecteurClean = UCase(Trim(CStr(motDirecteur)))
    voieClean = UCase(Trim(CStr(voie)))
    
    ' Commencer avec la voie complète
    resteVoie = Trim(CStr(voie))
    
    ' Stratégie 1: Le mot directeur est au début de la voie
    If InStr(1, voieClean, motDirecteurClean) = 1 Then
        resteVoie = Trim(Mid(resteVoie, Len(motDirecteurClean) + 1))
        Debug.Print "Suppression au début - Reste: '" & resteVoie & "'"
    End If
    
    ' Stratégie 2: Le mot directeur est à la fin de la voie (comme "ROUTE DU PIC")
    If Right(voieClean, Len(motDirecteurClean)) = motDirecteurClean Then
        ' Vérifier qu'il y a un espace ou préposition avant
        Dim positionFin As Integer
        positionFin = Len(voieClean) - Len(motDirecteurClean) + 1
        If positionFin > 1 Then
            Dim caracterePrecedent As String
            caracterePrecedent = Mid(voieClean, positionFin - 1, 1)
            If caracterePrecedent = " " Then
                ' Enlever le mot directeur de la fin
                resteVoie = Trim(Left(resteVoie, Len(resteVoie) - Len(motDirecteurClean)))
                Debug.Print "Suppression à la fin - Reste: '" & resteVoie & "'"
            End If
        End If
    End If
    
    ' Stratégie 3: Le mot directeur est au milieu (avec des prépositions)
    ' Patterns comme "ROUTE DU PIC", "RUE DES TANINS", etc.
    Dim patterns As Variant
    patterns = Array(" DU " & motDirecteurClean, " DE " & motDirecteurClean, " DES " & motDirecteurClean, _
                    " DE LA " & motDirecteurClean, " DE L'" & motDirecteurClean)
    
    Dim i As Integer
    For i = 0 To UBound(patterns)
        If InStr(voieClean, patterns(i)) > 0 Then
            resteVoie = Replace(resteVoie, patterns(i), "", 1, 1, vbTextCompare)
            resteVoie = Trim(resteVoie)
            Debug.Print "Suppression pattern '" & patterns(i) & "' - Reste: '" & resteVoie & "'"
            Exit For
        End If
    Next i
    
    ' Nettoyer les prépositions orphelines au début ou à la fin
    resteVoie = Trim(resteVoie)
    
    ' Enlever prépositions au début
    If Left(UCase(resteVoie), 3) = "DE " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 3) = "DU " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 4) = "DES " Then
        resteVoie = Trim(Mid(resteVoie, 5))
    ElseIf Left(UCase(resteVoie), 3) = "LA " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 3) = "LE " Then
        resteVoie = Trim(Mid(resteVoie, 4))
    ElseIf Left(UCase(resteVoie), 4) = "LES " Then
        resteVoie = Trim(Mid(resteVoie, 5))
    End If
    
    ' Enlever prépositions à la fin
    If Right(UCase(resteVoie), 3) = " DE" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 3))
    ElseIf Right(UCase(resteVoie), 3) = " DU" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 3))
    ElseIf Right(UCase(resteVoie), 4) = " DES" Then
        resteVoie = Trim(Left(resteVoie, Len(resteVoie) - 4))
    End If
    
    Debug.Print "Reste final après nettoyage: '" & resteVoie & "'"
    
    ' Construire le format final
    If resteVoie <> "" And UCase(resteVoie) <> motDirecteurClean And Len(resteVoie) > 1 Then
        voieFormatee = motDirecteurClean & " (" & resteVoie & ")"
    Else
        voieFormatee = motDirecteurClean
    End If
    
    ' Ajouter les bornes si présentes
    If borne <> "" Then
        voieFormatee = voieFormatee & " " & borne
    End If
    
    Debug.Print "Résultat final: '" & voieFormatee & "'"
    FormatVoieAvecMotDirecteur = voieFormatee
End Function

Sub CreerEntetes(ByRef ws As Worksheet, ByVal nbColonnes As Integer)
    '=========================================================================
    ' CRÉATION DES EN-TÊTES
    '=========================================================================
    Dim col As Integer
    
    For col = 1 To nbColonnes
        Dim colBase As Integer
        colBase = (col - 1) * 4 + 1
        
        ws.Cells(1, colBase) = "Voie"
        ws.Cells(1, colBase + 1) = "Tournée"
        ws.Cells(1, colBase + 2) = "Sécable"
        ws.Cells(1, colBase + 3) = "Samedi"
        
        ' Mise en forme des en-têtes
        With ws.Range(ws.Cells(1, colBase), ws.Cells(1, colBase + 3))
            .Font.Bold = True
            .Interior.Color = RGB(180, 198, 231)
            .HorizontalAlignment = xlCenter
        End With
    Next col
End Sub

Sub AfficherNomCommune(ByRef ws As Worksheet, ByVal commune As String, ByVal ligne As Long, ByVal nbColonnes As Integer)
    '=========================================================================
    ' AFFICHAGE DU NOM DE LA COMMUNE
    '=========================================================================
    Dim dernierCol As Integer
    dernierCol = nbColonnes * 4
    
    ' Fusionner les cellules et écrire le nom de la commune
    With ws.Range(ws.Cells(ligne, 1), ws.Cells(ligne, dernierCol))
        .Merge
        .Value = UCase(commune)
        .Font.Bold = True
        .Font.Size = 12
        .Interior.Color = RGB(255, 255, 0) ' Jaune
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlMedium
    End With
End Sub

Sub AfficherVoiesReparties(ByRef ws As Worksheet, ByRef voiesArray As Variant, ByVal nbVoies As Long, _
                          ByRef ligneDebut As Long, ByVal nbColonnes As Integer, ByRef wsSource As Worksheet)
    '=========================================================================
    ' AFFICHAGE DES VOIES RÉPARTIES SUR LES COLONNES
    ' Avec fond vert si la voie contient des numéros (bornes)
    ' Avec mise en forme spéciale pour le mot directeur et changement de lettre
    '=========================================================================
    Dim voieIndex As Long
    Dim ligne As Long, col As Integer
    Dim maxLignes As Long
    Dim lettreActuelle As String
    Dim lettrePrecedente As String
    
    lettrePrecedente = ""
    
    ' Calculer le nombre maximum de lignes nécessaires
    maxLignes = Application.WorksheetFunction.Ceiling_Precise(nbVoies / nbColonnes, 1)
    
    voieIndex = 0
    
    For ligne = 0 To maxLignes - 1
        For col = 1 To nbColonnes
            If voieIndex < nbVoies Then
                Dim colBase As Integer
                colBase = (col - 1) * 4 + 1
                Dim ligneActuelle As Long
                ligneActuelle = ligneDebut + ligne
                
                ' Extraire le mot directeur de la voie
                Dim voieComplete As String
                voieComplete = CStr(voiesArray(voieIndex, 0))
                Dim motDirecteur As String
                motDirecteur = ExtraireMotDirecteur(voieComplete)
                
                ' Détecter changement de première lettre
                lettreActuelle = UCase(Left(motDirecteur, 1))
                Dim changementLettre As Boolean
                changementLettre = (lettreActuelle <> lettrePrecedente And lettrePrecedente <> "")
                
                ' Formater la voie avec indicateur de changement de lettre
                Dim voieFormatee As String
                If changementLettre Then
                    voieFormatee = "■ " & voieComplete ' Carré noir pour le changement
                Else
                    voieFormatee = voieComplete
                End If
                
                ' Écrire les données de la voie
                ws.Cells(ligneActuelle, colBase) = voieFormatee
                ws.Cells(ligneActuelle, colBase + 1) = voiesArray(voieIndex, 1) ' Tournée
                ws.Cells(ligneActuelle, colBase + 2) = voiesArray(voieIndex, 2) ' Sécable
                ws.Cells(ligneActuelle, colBase + 3) = voiesArray(voieIndex, 3) ' Samedi
                
                ' Mise en forme du mot directeur en gras
                Call MettreMotDirecteurEnGras(ws.Cells(ligneActuelle, colBase), motDirecteur)
                
                ' Vérifier s'il y a des numéros (bornes) dans la voie
                Dim aDesNumeros As Boolean
                aDesNumeros = VoieContientDesNumeros(voieComplete)
                
                Debug.Print "Ligne " & ligneActuelle & " - Voie: '" & voiesArray(voieIndex, 0) & "' - A des numéros: " & aDesNumeros
                
                ' Mise en forme des cellules
                With ws.Range(ws.Cells(ligneActuelle, colBase), ws.Cells(ligneActuelle, colBase + 3))
                    .Borders.LineStyle = xlContinuous
                    .VerticalAlignment = xlCenter
                    
                    ' Fond vert si la voie contient des numéros
                    If aDesNumeros Then
                        .Interior.Color = RGB(144, 238, 144) ' Vert clair
                        Debug.Print "Application du fond vert à la ligne " & ligneActuelle
                    Else
                        .Interior.Color = xlNone ' Pas de couleur de fond
                    End If
                End With
                
                ' Couleur alternée pour les tournées (seulement si pas de numéros)
                If voiesArray(voieIndex, 1) <> "" And Not aDesNumeros Then
                    ws.Cells(ligneActuelle, colBase + 1).Interior.Color = RGB(220, 230, 241)
                    Debug.Print "Application du fond bleu à la tournée ligne " & ligneActuelle
                End If
                
                lettrePrecedente = lettreActuelle
                voieIndex = voieIndex + 1
            End If
        Next col
    Next ligne
End Sub

Function ExtraireMotDirecteur(ByVal voieComplete As String) As String
    '=========================================================================
    ' EXTRAIT LE MOT DIRECTEUR D'UNE VOIE FORMATÉE
    ' Ex: "PIC (ROUTE) 25" → "PIC"
    '=========================================================================
    Dim posParenthese As Integer
    posParenthese = InStr(voieComplete, " (")
    
    If posParenthese > 0 Then
        ExtraireMotDirecteur = Trim(Left(voieComplete, posParenthese - 1))
    Else
        ' Si pas de parenthèses, prendre le premier mot
        Dim mots As Variant
        mots = Split(Trim(voieComplete), " ")
        If UBound(mots) >= 0 Then
            ExtraireMotDirecteur = Trim(mots(0))
        Else
            ExtraireMotDirecteur = Trim(voieComplete)
        End If
    End If
End Function

Sub MettreMotDirecteurEnGras(ByRef cellule As Range, ByVal motDirecteur As String)
    '=========================================================================
    ' MET LE MOT DIRECTEUR EN GRAS DANS LA CELLULE
    '=========================================================================
    Dim texteComplet As String
    Dim positionDebut As Integer
    Dim longueurMot As Integer
    
    texteComplet = cellule.Value
    
    ' Chercher la position du mot directeur dans le texte
    positionDebut = InStr(1, texteComplet, motDirecteur, vbTextCompare)
    
    If positionDebut > 0 Then
        longueurMot = Len(motDirecteur)
        
        ' Mettre en gras seulement le mot directeur
        With cellule.Characters(positionDebut, longueurMot).Font
            .Bold = True
            .Size = cellule.Font.Size ' Garder la même taille
        End With
    End If
End Sub

Function VoieContientDesNumeros(ByVal voie As String) As Boolean
    '=========================================================================
    ' VÉRIFIE SI UNE VOIE CONTIENT DES NUMÉROS (BORNES)
    ' Recherche des patterns comme "1 à 25", "185 à 295", ou numéros isolés
    '=========================================================================
    
    Debug.Print "Vérification numéros pour: '" & voie & "'"
    
    VoieContientDesNumeros = False
    
    ' Chercher des patterns de plages de numéros
    If InStr(voie, " à ") > 0 Or _
       InStr(voie, " / ") > 0 Or _
       InStr(voie, "à") > 0 Or _
       InStr(voie, "/") > 0 Then
        
        ' Vérifier qu'il y a des chiffres
        Dim i As Integer
        For i = 1 To Len(voie)
            If IsNumeric(Mid(voie, i, 1)) Then
                VoieContientDesNumeros = True
                Debug.Print "Plage de numéros détectée dans: '" & voie & "'"
                Exit Function
            End If
        Next i
    End If
    
    ' Chercher des numéros isolés (après un espace à la fin)
    Dim mots As Variant
    mots = Split(Trim(voie), " ")
    If UBound(mots) >= 0 Then
        Dim dernierMot As String
        dernierMot = Trim(mots(UBound(mots)))
        
        ' Vérifier si le dernier mot est un nombre
        If IsNumeric(dernierMot) And Len(dernierMot) > 0 Then
            VoieContientDesNumeros = True
            Debug.Print "Numéro isolé détecté: '" & dernierMot & "' dans '" & voie & "'"
            Exit Function
        End If
        
        ' Vérifier si le dernier mot contient des chiffres et ressemble à une borne
        If Len(dernierMot) > 0 Then
            Dim contientChiffre As Boolean
            contientChiffre = False
            For i = 1 To Len(dernierMot)
                If IsNumeric(Mid(dernierMot, i, 1)) Then
                    contientChiffre = True
                    Exit For
                End If
            Next i
            
            ' Si contient des chiffres et des caractères de borne
            If contientChiffre And (InStr(dernierMot, "à") > 0 Or InStr(dernierMot, "/") > 0 Or InStr(dernierMot, "-") > 0) Then
                VoieContientDesNumeros = True
                Debug.Print "Pattern de borne détecté: '" & dernierMot & "' dans '" & voie & "'"
                Exit Function
            End If
        End If
    End If
    
    ' Chercher n'importe quel groupe de chiffres dans la chaîne (pour les cas comme TM0001 25)
    Dim j As Integer
    Dim numeroEnCours As String
    numeroEnCours = ""
    
    For j = 1 To Len(voie)
        Dim char As String
        char = Mid(voie, j, 1)
        
        If IsNumeric(char) Then
            numeroEnCours = numeroEnCours & char
        Else
            ' Si on a trouvé un nombre et qu'on arrive à un non-chiffre
            If Len(numeroEnCours) > 0 Then
                ' Vérifier si c'est un vrai numéro de voie (pas juste dans le code tournée)
                If Len(numeroEnCours) <= 3 And j > Len(voie) - 10 Then ' Numéro court en fin de chaîne
                    VoieContientDesNumeros = True
                    Debug.Print "Numéro de voie détecté: '" & numeroEnCours & "' dans '" & voie & "'"
                    Exit Function
                End If
                numeroEnCours = ""
            End If
        End If
    Next j
    
    ' Vérifier le dernier numéro si la chaîne se termine par un chiffre
    If Len(numeroEnCours) > 0 And Len(numeroEnCours) <= 3 Then
        VoieContientDesNumeros = True
        Debug.Print "Numéro final détecté: '" & numeroEnCours & "' dans '" & voie & "'"
    End If
    
    Debug.Print "Résultat détection: " & VoieContientDesNumeros
End Function

Sub AppliquerMiseEnForme(ByRef ws As Worksheet, ByVal nbColonnes As Integer)
    '=========================================================================
    ' MISE EN FORME FINALE
    '=========================================================================
    
    ' Ajuster la largeur des colonnes
    Dim col As Integer
    For col = 1 To nbColonnes
        Dim colBase As Integer
        colBase = (col - 1) * 4 + 1
        
        ws.Columns(colBase).ColumnWidth = 35      ' Voie
        ws.Columns(colBase + 1).ColumnWidth = 10  ' Tournée
        ws.Columns(colBase + 2).ColumnWidth = 10  ' Sécable
        ws.Columns(colBase + 3).ColumnWidth = 10  ' Samedi
    Next col
    
    ' Figer la première ligne
    ws.Rows("2:2").Select
    ActiveWindow.FreezePanes = True
    
    ' Sélectionner la cellule A1
    ws.Range("A1").Select
End Sub
